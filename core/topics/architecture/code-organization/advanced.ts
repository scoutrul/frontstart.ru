import { Topic } from '../../../types';

export const CODE_ORGANIZATION_ADVANCED_TOPICS: Topic[] = [
  {
    id: 'architecture-code-organization-advanced',
    title: 'ADR и архитектурные линтеры',
    difficulty: 'advanced',
    description: 'ADR (Architecture Decision Records) — документирование архитектурных решений. Каждое важное решение записывается в отдельный документ с контекстом, решением и последствиями. Это помогает понять, почему архитектура именно такая, и избежать повторения ошибок.\n\nАрхитектурные линтеры (dependency-cruiser, eslint-plugin-import) проверяют соблюдение правил зависимостей между модулями. Они предотвращают циклические зависимости, нарушение слоёв, неправильные импорты. Senior-разработчик должен использовать ADR и линтеры для поддержания архитектуры в больших проектах.',
    keyPoints: [
      'ADR (Architecture Decision Records): документирование архитектурных решений с контекстом и последствиями.',
      'Формат ADR: номер, название, контекст, решение, последствия, статус.',
      'Архитектурные линтеры: проверка правил зависимостей (dependency-cruiser, eslint-plugin-import).',
      'Правила: запрет циклических зависимостей, соблюдение слоёв, контроль импортов.',
      'Преимущества: поддержание архитектуры, понимание решений, предотвращение деградации.',
      'Применение: большие проекты, команды 10+ разработчиков, долгосрочная поддержка.'
    ],
    tags: ['architecture', 'adr', 'linting', 'dependencies', 'advanced'],
    examples: [
      {
        title: 'Пример ADR',
        code: `# ADR-001: Выбор Feature-Sliced Design

## Контекст
Проект вырос до 50+ компонентов, структура "по типам" стала неудобной.
Разные разработчики работают над разными фичами.

## Решение
Применить Feature-Sliced Design для организации кода по фичам и слоям.

## Последствия
- Плюсы: изоляция фич, легко масштабировать, понятная структура
- Минусы: кривая обучения, больше папок, нужно соблюдать правила зависимостей
- Риски: нарушение правил зависимостей, циклические зависимости

## Статус
Принято, внедрено в версии 2.0`
      },
      {
        title: 'Настройка архитектурного линтера',
        code: `// .dependency-cruiser.js
module.exports = {
  forbidden: [
    {
      name: 'no-circular',
      severity: 'error',
      comment: 'Запрет циклических зависимостей',
      from: {},
      to: {
        circular: true
      }
    },
    {
      name: 'no-lower-layer-import',
      severity: 'error',
      comment: 'Слои не могут импортировать из верхних слоёв',
      from: {
        path: '^(src/features|src/entities)'
      },
      to: {
        path: '^src/(pages|widgets)'
      }
    },
    {
      name: 'shared-only-from-shared',
      severity: 'warn',
      comment: 'shared может импортировать только из shared',
      from: {
        path: '^src/shared'
      },
      to: {
        path: '^(?!src/shared)'
      }
    }
  ]
};

// Запуск проверки
// npx dependency-cruiser src`
      }
    ],
    relatedTopics: ['architecture-code-organization-feature', 'architecture-audit-advanced'],
    funFact: 'ADR был предложен Майклом Найгардом в 2011 году для документирования архитектурных решений. Идея пришла из индустрии, где важные решения документируются для будущих поколений. ADR стал популярным в разработке ПО, особенно в больших проектах с долгосрочной поддержкой.',
    isFrontendEssential: true
  },
  {
    id: 'architecture-code-organization-micro-frontends',
    title: 'Подготовка к микрофронтендам',
    difficulty: 'advanced',
    description: 'Подготовка к микрофронтендам начинается с правильной организации монолита. Код должен быть разделён на независимые модули (фичи, домены), которые можно вынести в отдельные приложения. Нужно минимизировать зависимости между модулями, использовать shared библиотеки для общего кода.\n\nПринципы: изоляция модулей, чёткие границы, минимум общих зависимостей, версионирование API между модулями. Senior-разработчик должен проектировать монолит так, чтобы его можно было разделить на микрофронтенды без полной переработки.',
    keyPoints: [
      'Подготовка: разделение на независимые модули, минимизация зависимостей, чёткие границы.',
      'Изоляция: модули не должны напрямую зависеть друг от друга, общение через события/API.',
      'Shared библиотеки: общий код (UI компоненты, утилиты) выносится в отдельные пакеты.',
      'Версионирование: API между модулями должно быть версионировано для независимой разработки.',
      'Инструменты: Module Federation (Webpack), Single-SPA, qiankun для организации микрофронтендов.',
      'Когда готово: модули независимы, минимум общих зависимостей, чёткие границы.'
    ],
    tags: ['architecture', 'micro-frontends', 'module-federation', 'advanced'],
    examples: [
      {
        title: 'Изоляция модулей',
        code: `// Модуль должен быть изолирован
// features/user-profile/
export function UserProfileModule() {
  // Вся логика внутри модуля
  // Не зависит от других модулей напрямую
  return <UserProfile />;
}

// Общение через события
window.addEventListener('user-updated', (event) => {
  // Реагировать на события других модулей
});

window.dispatchEvent(new CustomEvent('user-updated', {
  detail: { userId: 123 }
}));

// Shared библиотека
// packages/shared-ui/
export { Button, Input, Card } from './components';

// Использование в модулях
import { Button } from '@company/shared-ui';`
      }
    ],
    relatedTopics: ['architecture-scaling-micro-frontends'],
    funFact: 'Многие думают, что микрофронтенды — это современно, но идея разделения приложения на независимые части восходит к UNIX-философии 1970-х: "Делай одну вещь и делай её хорошо". Микрофронтенды — это применение этой философии к фронтенд-разработке.',
    isFrontendEssential: true
  }
];
