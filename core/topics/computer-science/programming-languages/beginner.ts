import { Topic } from '../../../types';

export const CS_PROGRAMMING_LANGUAGES_BEGINNER_TOPICS: Topic[] = [
  {
    id: "machine-code-assembler-languages",
    title: "Машинный код, ассемблер и языки программирования",
    difficulty: "beginner",
    description: "Первые программы записывались напрямую в машинном коде — наборах бинарных инструкций, строго соответствующих архитектуре процессора. Это было сложно, но позволяло напрямую управлять железом. Ассемблер (появившийся в начале 1950-х) стал промежуточным уровнем абстракции, отображающим машинные инструкции в более читаемую форму.\n\nРеволюция в языках произошла благодаря Грейс Хоппер (1906–1992), которая разработала первые компиляторы и участвовала в создании COBOL (Common Business-Oriented Language — Общий бизнес-ориентированный язык, 1959 г.). Она показала, что программирование — это язык общения человека и машины, и что инструкции можно писать на языке, близком к естественному. Именно она ввела термин «debugging» (отладка), буквально извлекая жука из реле в 1947 году.\n\nКаждый уровень абстракции скрывает детали реализации, позволяя программисту работать на более высоком уровне формализации. Языки программирования позволяют нам описывать алгоритмы, не задумываясь о конкретном устройстве транзисторов и регистров.",
    funFact: [
      "Революционное видение Грейс Хоппер (1906–1992) о доступности программирования для каждого сегодня воплотилось в языках высокого уровня и популярных инструментах визуальной разработки.",
      "Первый язык программирования высокого уровня FORTRAN (1957 г.) был создан Джоном Бэкусом (1924–2007) специально для упрощения сложных научных и инженерных математических расчётов."
    ],
    keyPoints: [
      "Грейс Хоппер (1906–1992): компиляторы и COBOL (1959)",
      "FORTRAN (1957): первый высокоуровневый язык",
      "Термин debugging (1947) и его происхождение",
      "Машинный код как бинарные инструкции",
      "Ассемблер (1950-е) как промежуточный уровень",
      "Уровни абстракции и независимость от железа"
    ],
    tags: ["programming-languages", "machine-code", "assembler", "abstraction", "computer-science", "basics"],
    examples: [
      {
        title: "Уровни абстракции",
        code: "// Машинный код: 10101010 00001111\n// Ассемблер: MOV AX, 15\n// Высокоуровневый: x = 15\n// Один алгоритм — разные уровни абстракции"
      },
      {
        title: "Формализация алгоритмов",
        code: "// Язык позволяет описывать алгоритмы\n// независимо от конкретного железа\n// Абстракция от архитектуры"
      }
    ],
    relatedTopics: ["cs-machine-code", "cs-program-and-instruction", "programming-languages-high-level"],
    isFrontendEssential: true
  },
  {
    id: "cs-program-and-instruction",
    title: "Программа и инструкция",
    difficulty: "beginner",
    description: "Программа для компьютера — это не «идея» и не «текст», а строго определённая последовательность инструкций, которые процессор способен выполнить. Каждая инструкция — это элементарная команда: загрузить данные, сложить, сравнить, перейти по адресу.\n\nИсторически программы появились раньше электронных компьютеров: как инструкции для людей и механических машин. Современный код — это продолжение той же идеи, только исполняемой автоматически. Программа — это формализация алгоритма в виде последовательности инструкций, которые могут быть автоматизированы.",
    funFact: [
      "На заре компьютерной эры первые «программы» представляли собой объёмные таблицы вычислений, которые люди-вычислители скрупулёзно выполняли вручную на протяжении многих недель и месяцев.",
      "С точки зрения физического процессора не существует таких понятий как «функция» или «цикл» — это исключительно высокоуровневые абстракции, созданные для удобства человеческого мышления."
    ],
    keyPoints: [
      "Программа как последовательность инструкций",
      "Инструкция как минимальная операция CPU",
      "Код как данные",
      "Абстракции поверх инструкций",
      "Формализация алгоритмов",
      "Автоматизация исполнения"
    ],
    tags: ["computer-science", "fundamentals", "programming", "abstraction", "basics", "engineering"],
    examples: [
      {
        title: "Инструкция против алгоритма",
        code: "// Алгоритм — идея\n// Инструкция — конкретное действие\n\n// CPU-подход:\nLOAD A\nADD B\nSTORE C\n\n// Формализация алгоритма"
      },
      {
        title: "Один код — разные исполнения",
        code: "// Один и тот же алгоритм\n// может быть реализован на разных языках\n// и выполнен на разном железе\n// Абстракция от реализации"
      }
    ],
    relatedTopics: ["cs-machine-code", "machine-code-assembler-languages", "cs-cpu-cycle"],
    isFrontendEssential: true
  },
  {
    id: "cs-machine-code",
    title: "Машинный код",
    difficulty: "beginner",
    description: "Машинный код — это набор бинарных инструкций, которые процессор понимает напрямую. Каждая команда кодируется числами и зависит от архитектуры конкретного CPU.\n\nЯзыки программирования высокого уровня существуют именно потому, что писать и читать машинный код человеку крайне сложно и небезопасно. Машинный код — это самый низкий уровень абстракции, напрямую соответствующий архитектуре процессора. Компиляторы и интерпретаторы переводят высокоуровневый код в машинный, скрывая детали реализации.",
    funFact: [
      "Один современный центральный процессор может поддерживать сотни уникальных машинных инструкций, каждая из которых выполняет элементарную логическую или арифметическую операцию на уровне транзисторов.",
      "Любая ошибка на уровне машинного кода является критической и неизбежно приводит к аварийному завершению программы или полному сбою всей операционной системы компьютера."
    ],
    keyPoints: [
      "Бинарные инструкции",
      "Зависимость от архитектуры",
      "Непосредственное исполнение CPU",
      "Основа всех языков",
      "Низкий уровень абстракции",
      "Компиляция и интерпретация"
    ],
    tags: ["computer-science", "binary", "architecture", "machine-code", "abstraction", "basics"],
    examples: [
      {
        title: "Бинарная инструкция",
        code: "// Пример условной инструкции\n// 10101010 00001111\n// Для человека — шум\n// для CPU — команда\n// Прямое соответствие архитектуре"
      },
      {
        title: "Почему нужен компилятор",
        code: "// Язык высокого уровня\n// ↓ компиляция\n// Машинный код\n// Абстракция от машинного кода"
      }
    ],
    relatedTopics: ["cs-program-and-instruction", "machine-code-assembler-languages", "cs-cpu-cycle"],
    isFrontendEssential: true
  },
  {
    id: "programming-languages-purpose",
    title: "Предназначение языков программирования",
    difficulty: "beginner",
    description: "Языки программирования создавались для решения конкретных задач в разных сферах. Исторически языки делились на категории: военные (Ada для критических систем), научные (FORTRAN для вычислений), прикладные (COBOL для бизнеса).\n\nСовременные языки эволюционировали к универсальности, но сохраняют специализацию. JavaScript, Python, Java, PHP, Go стали доминирующими благодаря веб-разработке. Для фронтендера важно понимать, почему JavaScript стал стандартом веба и как другие языки находят применение в веб-экосистеме.",
    funFact: [
      "Ada был назван в честь Ады Лавлейс (1815–1852) и создан по заказу Министерства обороны США для критических военных систем, где надежность важнее удобства.",
      "PHP изначально расшифровывался как Personal Home Page Tools, но позже стал рекурсивным акронимом PHP: Hypertext Preprocessor, отражая его эволюцию в полноценный язык веб-разработки."
    ],
    keyPoints: [
      "Исторические категории: военные (Ada — надежность), научные (FORTRAN — вычисления), прикладные (COBOL — бизнес)",
      "Современные языки: JavaScript (веб-фронтенд), Python (веб-бэкенд, наука), Java (enterprise), PHP (веб-серверы), Go (микросервисы)",
      "Эволюция к веб-разработке: языки адаптировались под задачи веба (JS в браузере, PHP на сервере)",
      "JavaScript: создан для браузера, стал стандартом веба благодаря монополии в браузерах",
      "Специализация vs универсальность: современные языки универсальны, но сохраняют сильные стороны",
      "Выбор языка зависит от задачи: веб — JavaScript/TypeScript, мобильная — Swift/Kotlin, системная — Go/Rust"
    ],
    tags: ["programming-languages", "history", "purpose", "web-development", "computer-science", "basics"],
    examples: [
      {
        title: "Исторические языки по назначению",
        code: "// FORTRAN (1957) — научные вычисления\n// COBOL (1959) — бизнес-приложения\n// Ada (1980) — военные и критические системы\n\n// Каждый язык создавался\n// для конкретной сферы"
      },
      {
        title: "Современные языки для веба",
        code: "// JavaScript — фронтенд (браузер)\n// PHP — бэкенд (сервер)\n// Python — бэкенд, наука, автоматизация\n// Java — enterprise, большие системы\n// Go — микросервисы, облако\n\n// Все адаптировались под веб"
      },
      {
        title: "Почему JavaScript доминирует в вебе",
        code: "// JavaScript — единственный язык,\n// который выполняется в браузере\n// Монополия → стандарт\n\n// TypeScript — надстройка для безопасности\n// WebAssembly — альтернатива для производительности\n\n// Но JS остается основой веба"
      }
    ],
    relatedTopics: ["programming-languages-high-level", "machine-code-assembler-languages"],
    isFrontendEssential: true
  },
  {
    id: "programming-languages-high-level",
    title: "Высокоуровневые языки программирования",
    difficulty: "beginner",
    description: "Языки программирования появились как способ описывать алгоритмы в форме, понятной человеку и исполнимой машиной. Они скрывают аппаратные детали и позволяют мыслить на уровне абстракций. Первым таким языком стал FORTRAN (Formula Translation — Трансляция формул, 1957), а позже появились C (1972) и Ada (1980), названный в честь Ады Лавлейс (1815–1852).\n\nКаждый язык — это компромисс между удобством, контролем и производительностью. Высокоуровневые языки создают абстракции, позволяющие формализовать алгоритмы независимо от конкретного оборудования. Для разработчика важно понимать, что язык — это инструмент формализации, а не цель.",
    funFact: [
      "Первые языки программирования концептуально были гораздо ближе к чистой математике и формальной логике, чем к привычному нам сегодня синтаксису современных скриптовых языков.",
      "Популярный язык JavaScript был создан Брендоном Айком (р. 1961) всего за десять дней, однако он до сих пор остается главным инструментом разработки для всего мирового интернета."
    ],
    keyPoints: [
      "Язык как интерфейс между человеком и машиной",
      "FORTRAN (1957), C (1972), Ada (1980) как вехи развития",
      "Высокоуровневые и низкоуровневые языки",
      "Компиляция и интерпретация",
      "Абстракции как способ управления сложностью",
      "Формализация алгоритмов",
      "Независимость от оборудования"
    ],
    tags: ["programming", "languages", "abstraction", "fundamentals", "computer-science", "basics"],
    examples: [
      {
        title: "Один алгоритм — разные языки",
        code: "// JavaScript\nx = x + 1\n\n// Python\nx = x + 1\n\n// C++\nx = x + 1\n\n// Одна формализация — разные языки"
      },
      {
        title: "Абстракция от железа",
        code: "// Разработчик не управляет\n// регистрами напрямую\n// Язык скрывает детали реализации"
      }
    ],
    relatedTopics: ["machine-code-assembler-languages", "cs-program-and-instruction", "operating-systems-platform"],
    isFrontendEssential: true
  },
  {
    id: "programming-languages-typing",
    title: "Типизация языков",
    difficulty: "beginner",
    description: "Типизация определяет, когда и как язык проверяет соответствие типов данных. Статическая типизация проверяет типы на этапе компиляции, динамическая — во время выполнения. Сильная типизация строго контролирует преобразования типов, слабая — допускает автоматические преобразования.\n\nДля фронтендера важно понимать, что JavaScript использует динамическую и слабую типизацию, что дает гибкость, но может приводить к ошибкам. TypeScript добавляет статическую типизацию поверх JavaScript, обеспечивая безопасность типов на этапе разработки.",
    keyPoints: [
      "Статическая типизация: проверка типов на этапе компиляции (TypeScript, Java, C++)",
      "Динамическая типизация: типы определяются во время выполнения (JavaScript, Python, Ruby)",
      "Сильная типизация: строгий контроль преобразований, явные приведения (Python, Rust)",
      "Слабая типизация: автоматические преобразования типов (JavaScript, PHP)",
      "JavaScript: динамическая и слабая типизация — гибкость, но риск ошибок",
      "TypeScript: статическая типизация для JavaScript — безопасность на этапе разработки",
      "Компромиссы: статическая типизация — безопасность, динамическая — гибкость"
    ],
    tags: ["programming-languages", "typing", "types", "static-typing", "dynamic-typing", "computer-science", "basics"],
    examples: [
      {
        title: "Статическая vs динамическая типизация",
        code: "// Статическая (TypeScript)\nlet age: number = 25;\nage = \"25\"; // Ошибка компиляции!\n\n// Динамическая (JavaScript)\nlet age = 25;\nage = \"25\"; // Работает, тип изменился"
      },
      {
        title: "Сильная vs слабая типизация",
        code: "// Сильная (Python)\n\"5\" + 3  # TypeError: нельзя сложить строку и число\n\n// Слабая (JavaScript)\n\"5\" + 3  // \"53\" (автоматическое преобразование)\n\"5\" - 3  // 2 (автоматическое преобразование)"
      },
      {
        title: "TypeScript как статическая типизация для JS",
        code: "// TypeScript добавляет типы\nfunction add(a: number, b: number): number {\n  return a + b;\n}\n\nadd(5, 3);     // OK\nadd(\"5\", 3);  // Ошибка компиляции\n\n// Компилируется в обычный JavaScript\n// Типы проверяются только на этапе разработки"
      }
    ],
    relatedTopics: ["programming-languages-high-level", "data-types"],
    isFrontendEssential: true
  },
  {
    id: "programming-languages-paradigms",
    title: "Парадигмы программирования",
    difficulty: "beginner",
    description: "Парадигма программирования определяет стиль и подход к написанию кода. Императивная парадигма описывает последовательность команд, объектно-ориентированная — работу с объектами и классами, функциональная — вычисления через функции, декларативная — описание желаемого результата.\n\nМногие языки поддерживают несколько парадигм. JavaScript — мультипарадигменный язык, позволяющий использовать императивный, объектно-ориентированный и функциональный стили. Для фронтендера важно понимать, когда какую парадигму применять.",
    keyPoints: [
      "Императивная: последовательность команд, циклы, условия (C, Pascal, ранний JavaScript)",
      "Объектно-ориентированная: классы, объекты, наследование, инкапсуляция (Java, C++, Python)",
      "Функциональная: чистые функции, высшие функции, композиция (Haskell, Lisp, частично JavaScript)",
      "Декларативная: описание результата, а не процесса (SQL, HTML, CSS)",
      "Мультипарадигменные языки: поддержка нескольких стилей (JavaScript, Python, C++)",
      "JavaScript: императивный, ООП (классы), функциональный (map, filter, reduce), событийно-ориентированный",
      "Выбор парадигмы зависит от задачи: декларативный для UI, функциональный для обработки данных"
    ],
    tags: ["programming-languages", "paradigms", "oop", "functional", "imperative", "declarative", "computer-science", "basics"],
    examples: [
      {
        title: "Императивный стиль",
        code: "// Последовательность команд\nlet sum = 0;\nfor (let i = 0; i < arr.length; i++) {\n  sum += arr[i];\n}\nconsole.log(sum);"
      },
      {
        title: "Функциональный стиль",
        code: "// Чистые функции, композиция\nconst sum = arr.reduce((acc, val) => acc + val, 0);\n\n// Высшие функции\nconst doubled = arr.map(x => x * 2);\nconst filtered = arr.filter(x => x > 0);"
      },
      {
        title: "Объектно-ориентированный стиль",
        code: "// Классы и объекты\nclass User {\n  constructor(name) {\n    this.name = name;\n  }\n  greet() {\n    return `Hello, ${this.name}`;\n  }\n}\n\nconst user = new User('John');\nuser.greet();"
      },
      {
        title: "Декларативный стиль",
        code: "// HTML: описываем структуру, не процесс\n<div>\n  <h1>Title</h1>\n  <p>Content</p>\n</div>\n\n// SQL: описываем что нужно, не как получить\nSELECT name FROM users WHERE age > 18;"
      }
    ],
    relatedTopics: ["programming-languages-high-level", "multiparadigm"],
    isFrontendEssential: true
  },
  {
    id: "programming-languages-abstraction-level",
    title: "Уровень абстракции языков",
    difficulty: "beginner",
    description: "Уровень абстракции языка определяет, насколько он скрывает детали реализации от разработчика. Низкоуровневые языки дают прямой контроль над памятью и железом, высокоуровневые — скрывают эти детали, упрощая разработку.\n\nКомпромисс между контролем и удобством определяет выбор языка. Для фронтендера важно понимать, что JavaScript — высокоуровневый язык, который скрывает работу с памятью, потоками и системными вызовами, но это ограничивает контроль над производительностью.",
    keyPoints: [
      "Низкоуровневые: прямой контроль над памятью, регистрами, железом (C, Rust, ассемблер)",
      "Высокоуровневые: абстракции от железа, автоматическое управление памятью (JavaScript, Python, Java)",
      "Компромиссы: низкий уровень — контроль и производительность, высокий — удобство и безопасность",
      "JavaScript: высокоуровневый — GC, абстракции от потоков, событийная модель",
      "Уровень абстракции влияет на производительность, безопасность, сложность разработки",
      "Современные языки: баланс между абстракцией и контролем (Go, Rust)"
    ],
    tags: ["programming-languages", "abstraction", "low-level", "high-level", "computer-science", "basics"],
    examples: [
      {
        title: "Низкоуровневый контроль (C)",
        code: "// Прямая работа с памятью\nint* arr = malloc(10 * sizeof(int));\narr[0] = 42;\nfree(arr);  // Ручное управление памятью\n\n// Прямой доступ к системным вызовам\n// Контроль над каждым байтом"
      },
      {
        title: "Высокоуровневые абстракции (JavaScript)",
        code: "// Автоматическое управление памятью\nconst arr = [1, 2, 3];\n// GC сам освободит память\n\n// Абстракции от потоков\nsetTimeout(() => {\n  console.log('Async');\n}, 1000);\n// Event loop скрывает детали потоков"
      },
      {
        title: "Компромиссы",
        code: "// Низкий уровень: контроль, но сложность\n// C: быстрый, но ручное управление памятью\n\n// Высокий уровень: удобство, но ограничения\n// JavaScript: простой, но меньше контроля\n\n// Современные языки: баланс\n// Rust: безопасность памяти + производительность"
      }
    ],
    relatedTopics: ["programming-languages-high-level", "machine-code-assembler-languages", "cs-machine-code"],
    isFrontendEssential: true
  }
];
