import { Topic } from '../../../types';

export const CS_ARCHITECTURE_SEPARATION_BEGINNER_TOPICS: Topic[] = [
  {
    id: "architecture-layers-of-abstraction",
    title: "Слои абстракций",
    difficulty: "beginner",
    description: "Архитектура вычислительных систем построена на принципе слоёв абстракций: каждый слой скрывает детали реализации нижнего уровня, предоставляя более простой и удобный интерфейс. Это позволяет управлять сложностью системы, разделяя её на независимые уровни.\n\nСлои архитектуры идут от физического железа к прикладным программам: железо (процессор, память) → операционная система → виртуальные машины и интерпретаторы → языки программирования → рантаймы → приложения. Каждый слой решает свои задачи и предоставляет абстракции для следующего уровня.\n\nДля фронтенд-разработчика понимание слоёв важно, чтобы знать, на каком уровне работает код, где происходят задержки и ограничения, и как оптимизировать производительность. JavaScript код работает на уровне языка, но выполняется через рантайм, который взаимодействует с ОС и железом.",
    funFact: [
      "Принцип слоёв абстракций используется не только в компьютерах, но и в других инженерных системах: от строительства зданий до проектирования автомобилей.",
      "Современный браузер содержит более 20 миллионов строк кода, организованных в десятки слоёв абстракций."
    ],
    keyPoints: [
      "Слои абстракций: каждый слой скрывает детали нижнего уровня",
      "Цепочка слоёв: железо → ОС → виртуальные машины → языки → рантаймы → приложения",
      "Принцип: абстракция через скрытие деталей реализации",
      "Независимость слоёв: изменения в одном слое не требуют изменений в других",
      "Интерфейсы между слоями: API и протоколы как границы",
      "Для фронтенда: понимание, на каком слое работает код и где происходят ограничения"
    ],
    tags: ["architecture", "abstraction", "layers", "computer-science", "basics"],
    examples: [
      {
        title: "Слои архитектуры",
        code: "// Уровень 1: Железо\n// CPU, память, устройства\n\n// Уровень 2: ОС\n// Абстракция над железом\n// Управление ресурсами\n\n// Уровень 3: Виртуальные машины\n// JVM, V8, Python интерпретатор\n\n// Уровень 4: Языки\n// JavaScript, Python, Java\n\n// Уровень 5: Рантаймы\n// Node.js, браузер\n\n// Уровень 6: Приложения\n// Веб-приложения, программы"
      },
      {
        title: "Абстракция через скрытие деталей",
        code: "// JavaScript код:\nconst data = fetch('/api/data');\n\n// Не нужно знать:\n// - Как работает сетевой стек ОС\n// - Как процессор обрабатывает инструкции\n// - Как память выделяется\n\n// Слои скрывают детали\n// Предоставляют простой интерфейс"
      },
      {
        title: "Интерфейсы между слоями",
        code: "// API как границы:\n// JavaScript → fetch API → браузер\n// Браузер → системные вызовы → ОС\n// ОС → драйверы → железо\n\n// Каждый слой предоставляет\n// интерфейс для следующего"
      }
    ],
    relatedTopics: ["architecture-hardware-processor", "architecture-operating-systems", "architecture-javascript-layers"],
    isFrontendEssential: true
  },
  {
    id: "architecture-hardware-processor",
    title: "Железо и процессор",
    difficulty: "beginner",
    description: "Архитектура железа и процессора определяет, как физические компоненты компьютера организованы и взаимодействуют. Архитектура процессора включает набор инструкций (ISA — Instruction Set Architecture), регистры для хранения данных, систему адресации памяти и разрядность (32 или 64 бита).\n\nАрхитектура фон Неймана, где программа и данные хранятся в одной памяти, стала основой современных компьютеров. Процессор выполняет инструкции последовательно, обращаясь к памяти по адресам. Разрядность архитектуры определяет размер данных, которые процессор может обработать за один такт, и объём адресуемой памяти.\n\nДля фронтенд-разработчика понимание архитектуры железа важно, чтобы осознавать ограничения производительности: почему доступ к памяти медленнее операций в процессоре, почему большие массивы обрабатываются дольше, и как разрядность влияет на производительность. Современные браузеры и Node.js работают на 64-битных системах, что позволяет эффективно работать с большими объёмами данных.",
    funFact: [
      "Первый микропроцессор Intel 4004 (1971) был 4-битным и работал на частоте 740 кГц. Современные процессоры — 64-битные и работают на частотах свыше 3 ГГц.",
      "64-битная архитектура позволяет адресовать до 18 эксабайт памяти, хотя физически современные системы ограничены меньшими объёмами."
    ],
    keyPoints: [
      "Архитектура процессора: ISA (набор инструкций), регистры, адресация памяти",
      "Архитектура фон Неймана: программа и данные в одной памяти, последовательное выполнение",
      "Разрядность (32/64 bit): размер данных за один такт, объём адресуемой памяти",
      "Регистры: быстрая память внутри процессора для временных данных",
      "Адресация памяти: процессор обращается к данным по адресам",
      "Ограничения производительности: доступ к памяти медленнее операций в CPU"
    ],
    tags: ["architecture", "hardware", "processor", "cpu", "isa", "computer-science", "basics"],
    examples: [
      {
        title: "Архитектура процессора",
        code: "// ISA: набор инструкций\n// ADD, SUB, MOV, JMP\n\n// Регистры: быстрая память\n// EAX, EBX, ECX (32-bit)\n// RAX, RBX, RCX (64-bit)\n\n// Адресация памяти:\n// MOV EAX, [0x1000]\n// Загрузить данные по адресу"
      },
      {
        title: "Разрядность архитектуры",
        code: "// 32-bit:\n// - Обрабатывает 32 бита за такт\n// - До 4 ГБ адресуемой памяти\n// - Регистры: EAX, EBX\n\n// 64-bit:\n// - Обрабатывает 64 бита за такт\n// - До 18 ЭБ адресуемой памяти\n// - Регистры: RAX, RBX\n\n// Современные системы: 64-bit"
      },
      {
        title: "Ограничения производительности",
        code: "// Операции в CPU: очень быстро\n// ADD, SUB: наносекунды\n\n// Доступ к памяти: медленнее\n// L1 cache: ~1ns\n// RAM: ~100ns\n// Disk: миллисекунды\n\n// Почему большие массивы\n// обрабатываются медленнее"
      },
      {
        title: "Архитектура фон Неймана",
        code: "// Программа и данные\n// в одной памяти\n\n// CPU:\n// 1. Загрузить инструкцию\n// 2. Выполнить\n// 3. Загрузить данные\n// 4. Обработать\n// 5. Сохранить результат\n\n// Последовательное выполнение"
      }
    ],
    relatedTopics: ["cs-computer-architecture", "processors-transistors", "cs-cpu-cycle", "architecture-layers-of-abstraction"],
    isFrontendEssential: true
  },
  {
    id: "architecture-operating-systems",
    title: "ОС как слой абстракции",
    difficulty: "beginner",
    description: "Операционная система — это слой абстракции над железом, который управляет ресурсами компьютера: процессором, памятью, устройствами ввода-вывода. Архитектура ОС определяет, как организовано ядро системы, как разделены пользовательское и системное пространства, и как управляются процессы и потоки.\n\nАрхитектура ядра может быть монолитной (большая часть функциональности в ядре) или микроядром (минимальное ядро, сервисы в пространстве пользователя). Пространства разделяют код, который работает с привилегиями ядра, от кода приложений. Процессы и потоки — это архитектурные единицы выполнения, которые ОС планирует и управляет.\n\nДля фронтенд-разработчика важно понимать, что Node.js и браузер работают поверх ОС, используя её API для доступа к ресурсам. ОС управляет памятью, процессами и сетевыми соединениями, предоставляя абстракции для приложений. Понимание архитектуры ОС помогает отлаживать проблемы производительности и понимать ограничения среды выполнения.",
    funFact: [
      "Первая операционная система была создана в 1950-х годах для управления пакетной обработкой задач на мейнфреймах.",
      "Современные ОС содержат миллионы строк кода и управляют сложными многопроцессорными системами."
    ],
    keyPoints: [
      "ОС как слой абстракции над железом: управление процессором, памятью, устройствами",
      "Архитектура ядра: монолитное (Linux, большинство Unix) vs микроядро (минимальное ядро, сервисы в пользовательском пространстве)",
      "Пространства: пользовательское (приложения) и системное (ядро ОС)",
      "Процессы и потоки: архитектурные единицы выполнения, планирование ОС",
      "Управление ресурсами: память, CPU, устройства ввода-вывода",
      "API ОС: интерфейс для приложений (системные вызовы, файловая система, сеть)"
    ],
    tags: ["architecture", "operating-systems", "kernel", "processes", "threads", "computer-science", "basics"],
    examples: [
      {
        title: "ОС как слой абстракции",
        code: "// Приложение не работает\n// напрямую с железом\n\n// Приложение → API ОС → Ядро → Железо\n\n// ОС предоставляет:\n// - Файловую систему\n// - Управление памятью\n// - Сетевые интерфейсы\n// - Планирование процессов"
      },
      {
        title: "Пространства: пользовательское и системное",
        code: "// Пользовательское пространство:\n// - Приложения (Node.js, браузер)\n// - Ограниченные права\n// - Системные вызовы для доступа к ресурсам\n\n// Системное пространство:\n// - Ядро ОС\n// - Полные права\n// - Прямой доступ к железу\n\n// Разделение для безопасности"
      },
      {
        title: "Процессы и потоки",
        code: "// Процесс: изолированная программа\n// - Собственная память\n// - Отдельный адресный пространство\n\n// Поток: единица выполнения\n// - Разделяет память процесса\n// - Планируется ОС\n\n// Node.js: один процесс,\n// несколько потоков (worker threads)"
      },
      {
        title: "API ОС для приложений",
        code: "// Node.js использует API ОС:\nconst fs = require('fs');\nfs.readFile('file.txt', ...);\n// Системный вызов → ОС → файловая система\n\n// Браузер использует API ОС:\n// Сетевые запросы → ОС → сетевой стек\n// Рендеринг → ОС → графический драйвер"
      }
    ],
    relatedTopics: ["operating-systems-platform", "operating-systems-execution-architecture", "operating-systems-similarities-differences", "architecture-layers-of-abstraction"],
    isFrontendEssential: true
  },
  {
    id: "architecture-virtual-machines-interpreters",
    title: "Виртуальные машины и интерпретаторы",
    difficulty: "beginner",
    description: "Виртуальные машины и интерпретаторы создают дополнительный слой абстракции над операционной системой, позволяя выполнять код, написанный на языках высокого уровня. Виртуальная машина выполняет промежуточное представление (байткод), а интерпретатор выполняет код построчно или компилирует его в машинный код.\n\nБайткод — это промежуточное представление программы, которое не является машинным кодом, но и не является исходным кодом. JIT-компиляция (Just-In-Time) компилирует код во время выполнения для оптимизации. Разные языки используют разные подходы: Java использует JVM с байткодом, Python использует интерпретатор, JavaScript в V8 использует байткод и JIT-компиляцию.\n\nДля фронтенд-разработчика важно понимать, как работает V8: он парсит JavaScript, создаёт байткод, и затем JIT-компилирует горячие функции в оптимизированный машинный код. Это позволяет JavaScript работать быстро, несмотря на то, что это интерпретируемый язык.",
    funFact: [
      "Первая виртуальная машина была создана в 1960-х годах для языка Simula, предшественника объектно-ориентированного программирования.",
      "V8 компилирует JavaScript в машинный код, что делает его одним из самых быстрых интерпретаторов JavaScript."
    ],
    keyPoints: [
      "Виртуальные машины: слой абстракции над ОС, выполнение промежуточного представления",
      "Байткод: промежуточное представление программы (не машинный код, не исходный код)",
      "Интерпретация: построчное выполнение кода без предварительной компиляции",
      "JIT-компиляция: компиляция во время выполнения для оптимизации горячих функций",
      "Примеры: JVM (Java байткод), V8 (JavaScript байткод + JIT), Python интерпретатор",
      "Для фронтенда: V8 парсит JavaScript → байткод → JIT-компиляция → машинный код"
    ],
    tags: ["architecture", "virtual-machines", "interpreters", "bytecode", "jit", "computer-science", "basics"],
    examples: [
      {
        title: "Виртуальная машина как слой абстракции",
        code: "// Язык высокого уровня\n// ↓\n// Виртуальная машина\n// ↓\n// ОС\n// ↓\n// Железо\n\n// VM скрывает детали ОС\n// Предоставляет единый интерфейс"
      },
      {
        title: "Байткод как промежуточное представление",
        code: "// Исходный код:\nfunction add(a, b) {\n  return a + b;\n}\n\n// Байткод (упрощённо):\n// LOAD a\n// LOAD b\n// ADD\n// RETURN\n\n// Не машинный код,\n// но не исходный код"
      },
      {
        title: "JIT-компиляция в V8",
        code: "// JavaScript код\n// ↓ парсинг\n// AST (абстрактное синтаксическое дерево)\n// ↓ компиляция\n// Байткод (Ignition)\n// ↓ JIT для горячих функций\n// Машинный код (TurboFan)\n\n// Горячие функции → машинный код\n// Холодные функции → байткод"
      },
      {
        title: "Разные подходы",
        code: "// Java: JVM + байткод\n// .java → компилятор → .class (байткод)\n// JVM выполняет байткод\n\n// Python: интерпретатор\n// .py → интерпретатор → выполнение\n\n// JavaScript (V8): байткод + JIT\n// .js → парсинг → байткод → JIT → машинный код"
      }
    ],
    relatedTopics: ["programming-languages-execution", "architecture-layers-of-abstraction", "architecture-programming-languages"],
    isFrontendEssential: true
  },
  {
    id: "architecture-programming-languages",
    title: "Языки как слой абстракции",
    difficulty: "beginner",
    description: "Язык программирования — это слой абстракции над виртуальной машиной или интерпретатором, предоставляющий синтаксис и семантику для написания программ. Архитектура языка определяет систему типов, модель памяти, парадигмы программирования и способы взаимодействия с нижележащими слоями.\n\nСистема типов — это архитектурное решение, определяющее, как язык работает с типами данных: статическая или динамическая типизация, сильная или слабая. Модель памяти определяет, как язык управляет памятью: автоматическое управление через сборщик мусора или ручное управление. Парадигмы (объектно-ориентированное, функциональное, процедурное) — это архитектурные подходы к организации кода.\n\nДля фронтенд-разработчика важно понимать, что JavaScript работает через API, предоставляемые хост-средой (браузер или Node.js). Язык не имеет прямого доступа к файловой системе или сети — он использует API, которые реализованы в хост-среде и взаимодействуют с ОС.",
    funFact: [
      "Первый язык программирования высокого уровня FORTRAN был создан в 1957 году и использовал компилятор для перевода в машинный код.",
      "JavaScript был создан за 10 дней в 1995 году Бренданом Айком и изначально предназначался для простых скриптов в браузере."
    ],
    keyPoints: [
      "Язык как слой абстракции: синтаксис и семантика над VM/интерпретатором",
      "Система типов: архитектурное решение (статическая/динамическая, сильная/слабая типизация)",
      "Модель памяти: управление памятью (автоматическое через GC или ручное)",
      "Парадигмы: архитектурные подходы (ООП, функциональное, процедурное программирование)",
      "Взаимодействие через API: язык использует API хост-среды, не имеет прямого доступа к ресурсам",
      "Для фронтенда: JavaScript работает через API браузера/Node.js, которые взаимодействуют с ОС"
    ],
    tags: ["architecture", "programming-languages", "types", "memory", "paradigms", "computer-science", "basics"],
    examples: [
      {
        title: "Язык как слой абстракции",
        code: "// JavaScript код:\nconst data = fetch('/api/data');\n\n// Язык предоставляет синтаксис\n// Но реализация fetch — в хост-среде\n// (браузер или Node.js)\n\n// Язык → API хост-среды → ОС"
      },
      {
        title: "Система типов",
        code: "// Динамическая типизация (JavaScript):\nlet x = 5;      // число\nx = 'hello';   // строка\nx = {};        // объект\n\n// Статическая типизация (TypeScript):\nlet x: number = 5;\n// x = 'hello'; // ошибка\n\n// Архитектурное решение языка"
      },
      {
        title: "Модель памяти",
        code: "// Автоматическое управление (JavaScript):\nlet obj = { data: 'test' };\n// GC освободит память автоматически\n\n// Ручное управление (C):\nint* ptr = malloc(sizeof(int));\n// free(ptr); // нужно освободить вручную\n\n// Архитектурное решение языка"
      },
      {
        title: "Взаимодействие через API",
        code: "// JavaScript не имеет прямого доступа:\n// ❌ fs.readFile() — нет в браузере\n// ❌ socket.connect() — нет прямого доступа\n\n// Работает через API:\n// ✅ fetch() — API браузера/Node.js\n// ✅ document.getElementById() — API браузера\n// ✅ require('fs') — API Node.js\n\n// API реализованы в хост-среде"
      }
    ],
    relatedTopics: ["programming-languages-high-level", "programming-languages-execution", "programming-languages-abstractions-memory", "architecture-layers-of-abstraction"],
    isFrontendEssential: true
  }
];
