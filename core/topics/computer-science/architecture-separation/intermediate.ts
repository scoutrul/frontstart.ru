import { Topic } from '../../../types';

export const CS_ARCHITECTURE_SEPARATION_INTERMEDIATE_TOPICS: Topic[] = [
  {
    id: "architecture-runtimes",
    title: "Рантаймы",
    difficulty: "intermediate",
    description: "Рантайм (runtime) — это среда выполнения, которая обеспечивает выполнение программ, написанных на определённом языке. Архитектура рантайма включает управление памятью (стек, куча, сборщик мусора), взаимодействие с операционной системой через системные вызовы, и организацию выполнения кода (event loop, планирование задач).\n\nУправление памятью в рантайме организовано через стек (для локальных переменных и вызовов функций) и кучу (для динамически выделяемой памяти). Сборщик мусора (GC) автоматически освобождает неиспользуемую память в куче. Взаимодействие с ОС происходит через системные вызовы: рантайм запрашивает у ОС доступ к файловой системе, сети и другим ресурсам.\n\nДля фронтенд-разработчика важно понимать архитектуру рантайма JavaScript: event loop для асинхронности, управление памятью через GC, и как браузерный рантайм отличается от Node.js. Event loop позволяет JavaScript быть однопоточным, но при этом обрабатывать асинхронные операции без блокировки.",
    keyPoints: [
      "Рантайм как среда выполнения: обеспечивает выполнение программ, управление ресурсами",
      "Управление памятью: стек (локальные переменные, вызовы функций) и куча (динамическая память)",
      "Сборщик мусора (GC): автоматическое освобождение неиспользуемой памяти в куче",
      "Взаимодействие с ОС: системные вызовы для доступа к файловой системе, сети, устройствам",
      "Event loop: архитектурный паттерн для асинхронности в однопоточных языках (JavaScript)",
      "Различия рантаймов: браузерный (DOM, Web APIs) vs Node.js (fs, process, модули)"
    ],
    tags: ["architecture", "runtime", "memory", "garbage-collection", "event-loop", "computer-science", "intermediate"],
    examples: [
      {
        title: "Управление памятью: стек и куча",
        code: "// Стек: локальные переменные\nfunction calculate() {\n  let x = 5;  // в стеке\n  let y = 10; // в стеке\n  return x + y;\n}\n// После выхода из функции\n// переменные удаляются из стека\n\n// Куча: динамическая память\nlet obj = { data: 'test' }; // в куче\n// GC освободит, когда obj\n// больше не используется"
      },
      {
        title: "Сборщик мусора",
        code: "// GC отслеживает объекты в куче\nlet obj1 = { data: 'test' };\nlet obj2 = obj1;\n\nobj1 = null;\n// obj2 всё ещё ссылается на объект\n// GC не освободит память\n\nobj2 = null;\n// Теперь объект не используется\n// GC освободит память"
      },
      {
        title: "Event loop в JavaScript",
        code: "// Однопоточный JavaScript\n// использует event loop\n\nconsole.log('Start');\n\nsetTimeout(() => {\n  console.log('Timeout');\n}, 0);\n\nPromise.resolve().then(() => {\n  console.log('Promise');\n});\n\nconsole.log('End');\n\n// Вывод: Start, End, Promise, Timeout\n// Event loop обрабатывает\n// асинхронные задачи"
      },
      {
        title: "Взаимодействие с ОС",
        code: "// Node.js рантайм:\nconst fs = require('fs');\nfs.readFile('file.txt', (err, data) => {\n  // Системный вызов → ОС → файловая система\n});\n\n// Браузерный рантайм:\nfetch('/api/data')\n  .then(response => response.json())\n  // Системный вызов → ОС → сетевой стек\n\n// Рантайм абстрагирует\n// системные вызовы"
      },
      {
        title: "Различия рантаймов",
        code: "// Браузерный рантайм:\n// - DOM API\n// - Web APIs (fetch, localStorage)\n// - Event loop для UI\n// - Ограничения безопасности\n\n// Node.js рантайм:\n// - fs, process, модули\n// - Нет DOM\n// - Event loop для I/O\n// - Больше системных возможностей"
      }
    ],
    relatedTopics: ["programming-languages-execution", "programming-languages-abstractions-memory", "operating-systems-execution-architecture", "architecture-javascript-layers"],
    isFrontendEssential: true
  },
  {
    id: "architecture-separation-principles",
    title: "Принципы архитектурного разделения",
    difficulty: "intermediate",
    description: "Архитектурное разделение основано на принципах, которые позволяют управлять сложностью системы: декомпозиция, абстракция, модульность, разделение ответственности и инкапсуляция. Эти принципы применяются на всех уровнях архитектуры: от железа до приложений.\n\nДекомпозиция — это разделение системы на независимые модули, каждый из которых решает свою задачу. Абстракция скрывает детали реализации, предоставляя простой интерфейс. Модульность обеспечивает независимость компонентов с чёткими интерфейсами. Разделение ответственности означает, что каждый слой решает свои задачи и не вмешивается в работу других слоёв. Инкапсуляция изолирует детали внутри слоя, скрывая их от других слоёв.\n\nДля фронтенд-разработчика эти принципы важны при проектировании приложений: разделение на компоненты, абстракция через API, модульная архитектура, разделение логики и представления. Понимание принципов архитектурного разделения помогает создавать поддерживаемые и масштабируемые системы.",
    keyPoints: [
      "Декомпозиция: разделение системы на независимые модули, каждый решает свою задачу",
      "Абстракция: скрытие деталей реализации, предоставление простого интерфейса",
      "Модульность: независимые компоненты с чёткими интерфейсами, слабая связанность",
      "Разделение ответственности: каждый слой решает свои задачи, не вмешивается в другие",
      "Инкапсуляция: изоляция деталей внутри слоя, скрытие от других слоёв",
      "Применение в разработке: компоненты, API, модульная архитектура, разделение логики и представления"
    ],
    tags: ["architecture", "separation", "abstraction", "modularity", "encapsulation", "computer-science", "intermediate"],
    examples: [
      {
        title: "Декомпозиция",
        code: "// Система разделена на модули:\n// - UI компоненты\n// - Бизнес-логика\n// - Слой данных\n// - API клиент\n\n// Каждый модуль независим\n// Может разрабатываться отдельно"
      },
      {
        title: "Абстракция",
        code: "// Детали скрыты:\nfunction fetchUserData(userId) {\n  // Не нужно знать:\n  // - Как работает HTTP\n  // - Как парсится JSON\n  // - Как кэшируются данные\n  \n  // Простой интерфейс:\n  return api.get(`/users/${userId}`);\n}"
      },
      {
        title: "Модульность",
        code: "// Независимые модули:\n// userService.js\n// authService.js\n// dataService.js\n\n// Чёткие интерфейсы:\nexport function getUser(id) { ... }\nexport function createUser(data) { ... }\n\n// Слабая связанность:\n// Изменения в одном модуле\n// не влияют на другие"
      },
      {
        title: "Разделение ответственности",
        code: "// Каждый слой решает свои задачи:\n// UI: отображение, взаимодействие\n// Логика: бизнес-правила\n// Данные: хранение, получение\n\n// UI не знает, как хранятся данные\n// Логика не знает, как отображается UI\n// Данные не знают о бизнес-правилах"
      },
      {
        title: "Инкапсуляция",
        code: "// Детали изолированы:\nclass UserService {\n  // Приватные методы:\n  #validateUser(data) { ... }\n  #hashPassword(pwd) { ... }\n  \n  // Публичный интерфейс:\n  createUser(data) {\n    this.#validateUser(data);\n    // ...\n  }\n}\n\n// Внешний код не знает\n// о деталях реализации"
      }
    ],
    relatedTopics: ["architecture-layers-of-abstraction", "architecture-javascript-layers"],
    isFrontendEssential: true
  },
  {
    id: "architecture-javascript-layers",
    title: "Слои архитектур в JavaScript",
    difficulty: "intermediate",
    description: "JavaScript код выполняется через цепочку слоёв архитектуры: JavaScript код → движок (V8) → хост-среда (браузер/Node.js) → операционная система → железо. Каждый слой добавляет абстракцию и предоставляет API для следующего уровня.\n\nДвижок V8 парсит JavaScript, создаёт байткод и JIT-компилирует горячие функции в машинный код. Хост-среда (браузер или Node.js) предоставляет API: браузер даёт DOM, fetch, Web APIs, а Node.js даёт fs, process, модули. ОС управляет ресурсами: памятью, процессами, сетью. Железо выполняет инструкции на физическом уровне.\n\nДля фронтенд-разработчика понимание слоёв важно, чтобы знать, где происходят задержки и ограничения: сетевые запросы идут через ОС, рендеринг использует графический драйвер, память управляется ОС и GC. Оптимизация производительности требует понимания, на каком слое возникает проблема.",
    keyPoints: [
      "Цепочка слоёв: JavaScript код → V8 → хост (браузер/Node.js) → ОС → железо",
      "Движок V8: парсинг → байткод → JIT-компиляция → машинный код",
      "Хост-среда: браузер (DOM, fetch, Web APIs) vs Node.js (fs, process, модули)",
      "ОС: управление ресурсами (память, процессы, сеть, устройства)",
      "Железо: выполнение инструкций на физическом уровне",
      "API как границы: каждый слой предоставляет API для следующего уровня",
      "Задержки и ограничения: понимание, на каком слое возникает проблема производительности"
    ],
    tags: ["architecture", "javascript", "v8", "browser", "nodejs", "layers", "computer-science", "intermediate"],
    examples: [
      {
        title: "Цепочка выполнения JavaScript",
        code: "// Уровень 1: JavaScript код\nconst data = await fetch('/api/users');\n\n// Уровень 2: Движок V8\n// Парсинг → байткод → JIT → машинный код\n\n// Уровень 3: Хост (браузер)\n// fetch API → системный вызов\n\n// Уровень 4: ОС\n// Сетевой стек → драйвер сетевой карты\n\n// Уровень 5: Железо\n// Физическая передача данных"
      },
      {
        title: "Движок V8",
        code: "// JavaScript код\nfunction add(a, b) { return a + b; }\n\n// V8:\n// 1. Парсинг → AST\n// 2. Компиляция → байткод (Ignition)\n// 3. JIT для горячих функций → машинный код (TurboFan)\n\n// Горячие функции (вызываются часто)\n// компилируются в быстрый машинный код"
      },
      {
        title: "Хост-среда: браузер vs Node.js",
        code: "// Браузер:\n// - DOM API (document.getElementById)\n// - Web APIs (fetch, localStorage)\n// - Event loop для UI\n// - Ограничения безопасности (CORS)\n\n// Node.js:\n// - fs, process, модули\n// - Нет DOM\n// - Event loop для I/O\n// - Больше системных возможностей"
      },
      {
        title: "API как границы между слоями",
        code: "// JavaScript → V8 API\n// (синтаксис языка)\n\n// V8 → хост API\n// (fetch, DOM, fs)\n\n// Хост → ОС API\n// (системные вызовы)\n\n// ОС → железо\n// (драйверы, инструкции)\n\n// Каждый слой предоставляет\n// интерфейс для следующего"
      },
      {
        title: "Задержки и ограничения",
        code: "// Сетевой запрос:\n// JavaScript: мгновенно\n// V8: наносекунды\n// Браузер: микросекунды\n// ОС: миллисекунды\n// Сеть: десятки-сотни миллисекунд\n\n// Рендеринг:\n// JavaScript: быстро\n// DOM: может быть медленно\n// ОС/драйвер: зависит от железа\n\n// Понимание слоёв помогает\n// найти узкие места"
      },
      {
        title: "Оптимизация производительности",
        code: "// Проблема: медленный рендеринг\n// Слой: DOM/браузер\n// Решение: виртуализация, оптимизация DOM\n\n// Проблема: медленные вычисления\n// Слой: JavaScript/V8\n// Решение: оптимизация алгоритмов, Web Workers\n\n// Проблема: медленная сеть\n// Слой: ОС/сеть\n// Решение: кэширование, оптимизация запросов"
      }
    ],
    relatedTopics: ["architecture-layers-of-abstraction", "architecture-runtimes", "programming-languages-execution", "operating-systems-execution-architecture"],
    isFrontendEssential: true
  }
];
