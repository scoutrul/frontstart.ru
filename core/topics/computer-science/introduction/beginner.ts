import { Topic } from '../../../types';

export const CS_INTRODUCTION_BEGINNER_TOPICS: Topic[] = [
  {
    id: "computer-science-intro",
    title: "Информатика",
    difficulty: "beginner",
    description: "Информатика — это область знаний о вычислениях, информации и способах их автоматической обработки. Она изучает не конкретные компьютеры, а принципы, по которым данные представляются, передаются, хранятся и преобразуются.\n\nСовременные компьютеры, языки программирования и интернет — результат эволюции идей: алгоритмов, логики, архитектуры и абстракций.",
    funFact: "Слово «computer» изначально означало человека, который выполнял вычисления вручную.",
    keyPoints: [
      "Вычисления (формализованные действия для получения результата)",
      "Алгоритмы (инструкции, независимые от исполнителя)",
      "Автоматизация вычислений",
      "Представление информации",
      "Логика и архитектура",
      "Абстракции как основа программирования"
    ],
    tags: ["computer-science", "basics", "fundamentals", "history", "engineering"],
    examples: [
      {
        title: "Алгоритм как идея",
        code: "// Алгоритм существует независимо от языка\n// Найти сумму чисел от 1 до N\n\n1. Начать с суммы = 0\n2. Прибавлять каждое число от 1 до N\n3. Вернуть результат"
      }
    ],
    relatedTopics: ["intro-origins-of-computation", "intro-binary-system", "intro-computer-architecture"]
  },
  {
    id: "intro-origins-of-computation",
    title: "Истоки вычислений",
    difficulty: "beginner",
    description: "Задолго до появления компьютеров люди сталкивались с задачами, которые требовали точных и повторяемых вычислений: астрономия, навигация, налоги, строительство, военное дело. Первые вычислительные методы были тесно связаны с математикой и физикой, но ещё не с машинами — это были алгоритмы в голове человека или на бумаге.\n\nКлючевой сдвиг произошёл, когда стало ясно: вычисление — это не магия и не искусство, а последовательность формальных шагов, которые можно описать, повторить и, теоретически, передать машине. Это мышление и стало фундаментом всей информатики.\n\nДля разработчика важно понимать, что программирование выросло не из компьютеров, а из идеи формального решения задач. Компьютер — лишь ускоритель уже существующих алгоритмических процессов.",
    keyPoints: [
      "Вычисления появились раньше компьютеров",
      "Алгоритм как формальное описание решения",
      "От ручных расчётов к идее автоматизации",
      "Информатика начинается с мышления, а не с железа"
    ],
    funFact: "Термин «алгоритм» происходит от имени персидского математика Аль-Хорезми, жившего в IX веке. Его труды по вычислениям использовались в Европе столетиями — безо всяких компьютеров.",
    tags: ["computer-science", "history", "basics", "fundamentals"],
    examples: [
      {
        title: "Ручной алгоритм",
        code: "// Даже без компьютера алгоритм уже существует\n// Рецепт — тоже алгоритм"
      }
    ],
    relatedTopics: ["intro-mechanical-machines", "intro-idea-of-program", "intro-binary-system"]
  },
  {
    id: "intro-mechanical-machines",
    title: "Механические вычислительные машины",
    difficulty: "beginner",
    description: "Первыми попытками автоматизировать вычисления стали механические устройства. Они работали без электричества — на шестерёнках, рычагах и валах. Такие машины не «думали», но строго следовали заложенной в них механической логике.\n\nБлез Паскаль в XVII веке создал механический калькулятор для сложения и вычитания, а Готфрид Лейбниц расширил эту идею до умножения и деления. Эти устройства показали важную вещь: физическая система может выполнять абстрактные математические операции.\n\nДля программиста это важный момент: логика программы не обязана быть цифровой. Она может быть механической, электрической или абстрактной — принцип остаётся тем же.",
    keyPoints: [
      "Первые вычислительные устройства были механическими",
      "Операции реализовывались физическими механизмами",
      "Машина выполняет строго заданные правила",
      "Логика может быть реализована вне электроники"
    ],
    funFact: "Механические калькуляторы использовались в бухгалтерии и науке вплоть до середины XX века — даже после появления электронных компьютеров.",
    tags: ["computer-science", "history", "engineering", "basics"],
    examples: [
      {
        title: "Фиксированный алгоритм",
        code: "// Машина умеет только то,\n// что заложено конструкцией"
      }
    ],
    relatedTopics: ["intro-idea-of-program", "intro-binary-system"]
  },
  {
    id: "intro-idea-of-program",
    title: "Идея программы",
    difficulty: "beginner",
    description: "Следующий ключевой шаг — понимание, что машине можно задавать не только конкретную операцию, но и последовательность операций. Так появилась идея программы: заранее описанного набора инструкций, которые выполняются автоматически.\n\nАда Лавлейс, работая с аналитической машиной Чарльза Бэббиджа, первой описала алгоритм, не привязанный к конкретному вычислению. По сути, она сформулировала концепцию программирования ещё до появления работающего компьютера.\n\nДля современного разработчика это фундаментальное осознание: код — это не «набор команд для компьютера», а формализованное описание поведения системы во времени.",
    keyPoints: [
      "Программа — это последовательность инструкций",
      "Алгоритм отделяется от конкретных данных",
      "Код описывает поведение, а не вычисление одного значения",
      "Программирование появилось раньше компьютеров"
    ],
    funFact: "Ада Лавлейс считается первым программистом в истории, хотя при её жизни не существовало ни одного работающего компьютера.",
    tags: ["computer-science", "fundamentals", "history", "basics"],
    examples: [
      {
        title: "Инструкция отдельно от машины",
        code: "// Одна машина — разные программы\n// Это и есть идея программирования"
      }
    ],
    relatedTopics: ["intro-computer-architecture", "cs-programming-languages"]
  },
  {
    id: "intro-binary-system",
    title: "Двоичная система",
    difficulty: "beginner",
    description: "Двоичная система счисления — это способ представления информации с использованием только двух состояний: 0 и 1. Она идеально подходит для технических устройств, где проще надёжно различать два состояния, чем множество аналоговых значений.\n\nВ информатике двоичная система стала универсальным языком представления данных: чисел, текста, изображений, звука и программ. Для разработчика важно понимать, что за любыми высокоуровневыми абстракциями в конечном итоге стоят последовательности битов.",
    funFact: [
      "Готфрид Лейбниц описал двоичную систему ещё в XVII веке, задолго до появления электроники.",
      "В Древнем Китае двоичная логика использовалась в «Книге Перемен» (И Цзин) как философская модель мира."
    ],
    keyPoints: [
      "Два состояния как основа представления информации",
      "Связь двоичного кода с физическими состояниями",
      "Биты и байты как базовые единицы данных",
      "Универсальность двоичного представления"
    ],
    tags: ["binary", "encoding", "computer-science", "basics"],
    examples: [
      {
        title: "Число в двоичном виде",
        code: "// Десятичное число 13\n// В двоичной системе это:\n1101"
      },
      {
        title: "Текст как биты",
        code: "// Символ 'A' в ASCII\n01000001"
      }
    ],
    relatedTopics: ["intro-logic-and-gates", "cs-cpu-memory"]
  },
  {
    id: "intro-logic-and-gates",
    title: "Логика и вентили",
    difficulty: "beginner",
    description: "Логические операции описывают правила обработки булевых значений: истинно или ложно. В компьютерах эти операции реализуются с помощью логических вентилей — простейших схем, работающих с двоичными сигналами.\n\nИменно логика связывает абстрактные вычисления с физической реализацией. Любая программа, какой бы сложной она ни была, в конечном итоге сводится к комбинациям логических операций.",
    funFact: [
      "Любую вычислимую функцию можно реализовать, используя только вентиль NAND.",
      "Логические схемы можно собирать не только из транзисторов, но и из воды, домино и даже людей с табличками 0 и 1."
    ],
    keyPoints: [
      "Булева логика как основа вычислений",
      "Логические операции: AND, OR, NOT",
      "Вентили как физическая реализация логики",
      "Связь условий в коде с аппаратной логикой"
    ],
    tags: ["logic", "computer-science", "fundamentals", "basics"],
    examples: [
      {
        title: "Логическое И",
        code: "// AND\ntrue && false // false"
      },
      {
        title: "Условие в коде",
        code: "if (isLoggedIn && hasAccess) {\n  openPage();\n}"
      }
    ],
    relatedTopics: ["intro-binary-system", "cs-cpu-memory"]
  },
  {
    id: "intro-computer-architecture",
    title: "Архитектура компьютера",
    difficulty: "beginner",
    description: "Архитектура компьютера описывает, из каких основных компонентов состоит вычислительная система и как они взаимодействуют между собой. Классическая модель включает процессор, память и устройства ввода-вывода.\n\nДля разработчика архитектура важна не на уровне схем, а на уровне понимания ограничений: скорость памяти, стоимость операций, порядок выполнения инструкций. Эти факторы напрямую влияют на производительность программ.",
    funFact: [
      "Современные процессоры выполняют миллиарды инструкций в секунду, но всё ещё ждут память.",
      "Большая часть оптимизаций в ПО связана не с CPU, а с работой с памятью."
    ],
    keyPoints: [
      "Процессор как исполнитель инструкций",
      "Память как хранилище данных и программ",
      "Ввод-вывод как связь с внешним миром",
      "Узкие места архитектуры"
    ],
    tags: ["architecture", "cpu", "memory", "computer-science"],
    examples: [
      {
        title: "Последовательность выполнения",
        code: "// CPU выполняет инструкции по шагам\nload -> compute -> store"
      },
      {
        title: "Задержка памяти",
        code: "// Доступ к памяти медленнее операций в CPU\nlet x = arr[1000000];"
      }
    ],
    relatedTopics: ["cs-cpu-memory", "intro-programming-languages"]
  },
  {
    id: "intro-programming-languages",
    title: "Языки программирования",
    difficulty: "beginner",
    description: "Языки программирования появились как способ описывать алгоритмы в форме, понятной человеку и исполнимой машиной. Они скрывают аппаратные детали и позволяют мыслить на уровне абстракций.\n\nКаждый язык — это компромисс между удобством, контролем и производительностью. Для разработчика важно понимать, что язык — это инструмент, а не цель.",
    funFact: [
      "Первые языки программирования были ближе к математике, чем к современному коду.",
      "JavaScript был создан за 10 дней, но используется уже десятилетиями."
    ],
    keyPoints: [
      "Язык как интерфейс между человеком и машиной",
      "Высокоуровневые и низкоуровневые языки",
      "Компиляция и интерпретация",
      "Абстракции как способ управления сложностью"
    ],
    tags: ["programming", "fundamentals", "computer-science", "basics"],
    examples: [
      {
        title: "Один алгоритм — разные языки",
        code: "// JavaScript\nx = x + 1"
      },
      {
        title: "Абстракция от железа",
        code: "// Разработчик не управляет регистрами напрямую"
      }
    ],
    relatedTopics: ["intro-internet-and-web", "intro-modern-abstractions"]
  },
  {
    id: "intro-internet-and-web",
    title: "Интернет и веб",
    difficulty: "beginner",
    description: "Интернет — это глобальная сеть компьютеров, обменивающихся данными по стандартным протоколам. Веб — лишь одна из служб поверх интернета, предназначенная для передачи гипертекста и приложений.\n\nДля фронтенд-разработчика важно понимать, что браузер — это клиент в распределённой системе, а веб-приложение всегда работает в условиях задержек и ограничений сети.",
    funFact: [
      "Интернет и веб — не одно и то же.",
      "Первый веб-сайт до сих пор доступен в интернете."
    ],
    keyPoints: [
      "Разделение понятий интернет и веб",
      "Клиент-серверная модель",
      "Протоколы как правила общения",
      "Сеть как источник неопределённости"
    ],
    tags: ["networks", "browser", "computer-science", "basics"],
    examples: [
      {
        title: "Запрос и ответ",
        code: "GET /index.html\n\n200 OK"
      },
      {
        title: "Задержка сети",
        code: "// Даже быстрый код ждёт ответ сервера"
      }
    ],
    relatedTopics: ["intro-modern-abstractions"]
  },
  {
    id: "intro-modern-abstractions",
    title: "Современные абстракции",
    difficulty: "beginner",
    description: "Современное программирование строится на слоях абстракций: фреймворки, библиотеки, виртуальные машины, контейнеры. Они позволяют решать сложные задачи, не погружаясь в детали реализации.\n\nПонимание абстракций важно не для того, чтобы отказаться от них, а чтобы осознанно ими пользоваться и понимать, где проходит граница ответственности.",
    funFact: [
      "Современный браузер содержит больше кода, чем операционные системы 90-х.",
      "Большинство приложений работает поверх десятков уровней абстракций."
    ],
    keyPoints: [
      "Абстракция как инструмент упрощения",
      "Слои ответственности",
      "Цена удобства",
      "Умение опускаться уровнем ниже при необходимости"
    ],
    tags: ["computer-science", "fundamentals", "basics"],
    examples: [
      {
        title: "Фреймворк как слой",
        code: "// React скрывает работу с DOM"
      },
      {
        title: "Абстракция и контроль",
        code: "// Иногда приходится выходить за пределы API"
      }
    ],
    relatedTopics: []
  }
];
