import { Topic } from '../../../types';

export const NETWORK_TOOLS_INTERMEDIATE_TOPICS: Topic[] = [
  {
    id: 'network-timing',
    title: 'TTFB и тайминги запроса',
    difficulty: 'intermediate',
    description: 'Тайминги запроса показывают детальную разбивку времени загрузки ресурса. TTFB (Time To First Byte) — время от отправки запроса до получения первого байта ответа, ключевая метрика производительности сервера. Другие тайминги: DNS lookup, TCP connection, SSL negotiation, Request sent, Content download. Понимание таймингов помогает найти узкие места в производительности.',
    keyPoints: [
      'TTFB (Time To First Byte): время от отправки запроса до первого байта ответа, цель < 600ms, зависит от сервера и сети.',
      'DNS Lookup: время резолва DNS, обычно 20-120ms, можно оптимизировать через DNS-prefetch.',
      'Initial Connection: время установки TCP-соединения, обычно 50-200ms, зависит от сети и расстояния до сервера.',
      'SSL Negotiation: время TLS-рукопожатия, обычно 100-300ms, можно оптимизировать через session resumption.',
      'Request/Response: время отправки запроса и загрузки ответа, зависит от размера данных и пропускной способности.',
      'Анализ: длинный TTFB указывает на медленный сервер, длинный DNS — проблемы с DNS, длинный SSL — проблемы с сертификатом.'
    ],
    tags: ['networks', 'devtools', 'performance', 'ttfb', 'timing', 'intermediate'],
    examples: [
      {
        title: 'Разбивка таймингов',
        code: `// ПОЛНЫЙ ЦИКЛ ЗАПРОСА:

// 1. QUEUED (очередь)
//    Время ожидания перед началом запроса
//    Причины: другие запросы блокируют, нет доступных соединений

// 2. DNS LOOKUP (резолв DNS)
//    Время преобразования домена в IP
//    Обычно: 20-120ms
//    Оптимизация: DNS-prefetch

// 3. INITIAL CONNECTION (TCP)
//    Время установки TCP-соединения
//    Обычно: 50-200ms
//    Зависит от: расстояние до сервера, сеть

// 4. SSL (TLS-рукопожатие)
//    Время установки зашифрованного соединения
//    Обычно: 100-300ms
//    Оптимизация: TLS session resumption

// 5. REQUEST SENT
//    Время отправки запроса
//    Обычно: < 1ms (локально)
//    Зависит от: размер заголовков

// 6. WAITING (TTFB)
//    Время от отправки до первого байта
//    Обычно: 100-600ms
//    Зависит от: сервера, обработки запроса

// 7. CONTENT DOWNLOAD
//    Время загрузки данных
//    Зависит от: размера файла, пропускной способности`
      },
      {
        title: 'TTFB (Time To First Byte)',
        code: `// TTFB = время от отправки запроса до первого байта ответа

// ХОРОШО: < 200ms (локальный сервер)
// НОРМАЛЬНО: < 600ms (удалённый сервер)
// ПЛОХО: > 1000ms

// ЧТО ВЛИЯЕТ НА TTFB:
// 1. Время обработки на сервере
//    - Выполнение кода
//    - Запросы к БД
//    - Генерация ответа

// 2. Сетевая задержка (latency)
//    - Расстояние до сервера
//    - Качество сети

// 3. Прокси/CDN
//    - Время обработки прокси
//    - Кеширование

// ОПТИМИЗАЦИЯ:
// - Ускорить сервер (кэширование, оптимизация БД)
// - Использовать CDN (ближе к пользователям)
// - Кешировать ответы
// - Оптимизировать код`
      },
      {
        title: 'Анализ таймингов',
        code: `// ПРИМЕР ЗАПРОСА:
// DNS Lookup: 50ms
// Initial Connection: 150ms
// SSL: 250ms
// Request Sent: 1ms
// Waiting (TTFB): 800ms ← ПРОБЛЕМА
// Content Download: 200ms

// АНАЛИЗ:
// - TTFB 800ms → медленный сервер
//   Решение: оптимизировать сервер, использовать кеш

// ПРИМЕР 2:
// DNS Lookup: 300ms ← ПРОБЛЕМА
// Initial Connection: 200ms
// SSL: 300ms
// Waiting (TTFB): 200ms
// Content Download: 150ms

// АНАЛИЗ:
// - DNS 300ms → проблемы с DNS
//   Решение: использовать быстрый DNS (1.1.1.1, 8.8.8.8)
//   Или: DNS-prefetch

// ПРИМЕР 3:
// DNS Lookup: 50ms
// Initial Connection: 100ms
// SSL: 500ms ← ПРОБЛЕМА
// Waiting (TTFB): 200ms
// Content Download: 100ms

// АНАЛИЗ:
// - SSL 500ms → проблемы с сертификатом или сетью
//   Решение: проверить сертификат, оптимизировать TLS`
      },
      {
        title: 'Оптимизация таймингов',
        code: `// 1. DNS LOOKUP:
// - Использовать DNS-prefetch
<link rel="dns-prefetch" href="https://api.example.com">

// 2. INITIAL CONNECTION:
// - Использовать HTTP/2 (переиспользование соединений)
// - Использовать preconnect
<link rel="preconnect" href="https://api.example.com">

// 3. SSL:
// - Использовать TLS 1.3 (быстрее рукопожатие)
// - Включить session resumption
// - Использовать CDN с оптимизированным TLS

// 4. TTFB:
// - Кешировать ответы
// - Оптимизировать сервер (код, БД)
// - Использовать CDN
// - Минимизировать обработку на сервере

// 5. CONTENT DOWNLOAD:
// - Сжимать ресурсы (Gzip, Brotli)
// - Минифицировать код
// - Использовать современные форматы (WebP)`
      }
    ],
    relatedTopics: ['network-devtools', 'network-waterfall', 'performance-prefetch']
  },
  {
    id: 'network-waterfall',
    title: 'Водопад загрузки',
    difficulty: 'intermediate',
    description: 'Водопад загрузки — визуализация временной последовательности загрузки ресурсов страницы. Показывает, какие ресурсы загружаются параллельно, какие блокируют другие, зависимости между ресурсами. Анализ водопада помогает найти узкие места: блокирующие ресурсы, последовательную загрузку, долгие запросы. Понимание водопада критично для оптимизации производительности.',
    keyPoints: [
      'Визуализация: каждый запрос — горизонтальная полоса, длина = время загрузки, позиция = момент начала.',
      'Блокировки: серые блоки показывают время ожидания перед началом загрузки (блокировка другими ресурсами).',
      'Параллельность: запросы, начинающиеся одновременно, загружаются параллельно.',
      'Зависимости: некоторые запросы начинаются только после завершения других (например, JS после HTML).',
      'Узкие места: длинные запросы, много блокировок, последовательная загрузка вместо параллельной.',
      'Оптимизация: минимизировать блокировки, использовать async/defer для скриптов, preload для критических ресурсов.'
    ],
    tags: ['networks', 'devtools', 'performance', 'waterfall', 'intermediate'],
    examples: [
      {
        title: 'Чтение водопада',
        code: `// ВОДОПАД ПОКАЗЫВАЕТ:

// ВРЕМЯ →
// HTML:     [========]
// CSS:           [====]
// JS:                [==]
// Image1:              [=]
// Image2:              [=]

// АНАЛИЗ:
// - HTML загружается первым
// - CSS начинается после HTML (обнаружен в HTML)
// - JS начинается после CSS (блокируется CSS)
// - Images начинаются после JS
// - Image1 и Image2 загружаются параллельно

// ПРОБЛЕМЫ:
// - Последовательная загрузка (не параллельная)
// - Блокировки между ресурсами
// - Долгое время загрузки`
      },
      {
        title: 'Блокировки в водопаде',
        code: `// СЕРЫЕ БЛОКИ = блокировка:

// HTML:     [========]
// CSS:      [серый][====]
// JS:       [серый серый][==]

// АНАЛИЗ:
// - CSS блокируется HTML (ждёт парсинга)
// - JS блокируется HTML и CSS (ждёт загрузки CSS)

// ПРИЧИНЫ БЛОКИРОВОК:
// 1. Парсинг HTML (обнаружение ресурсов)
// 2. Блокирующие ресурсы (CSS, синхронный JS)
// 3. Ограничение соединений (HTTP/1.1: 6 на домен)
// 4. Зависимости (JS после CSS)

// РЕШЕНИЕ:
// - Использовать async/defer для JS
// - Inline критический CSS
// - Preload критических ресурсов
// - HTTP/2 (мультиплексирование)`
      },
      {
        title: 'Параллельная vs последовательная загрузка',
        code: `// ❌ ПОСЛЕДОВАТЕЛЬНАЯ (HTTP/1.1):
// HTML:     [========]
// CSS:           [====]
// JS:                [==]
// Image1:              [=]
// Image2:                  [=]
// Время: 1000ms

// ✅ ПАРАЛЛЕЛЬНАЯ (HTTP/2):
// HTML:     [========]
// CSS:      [====]
// JS:       [==]
// Image1:   [=]
// Image2:   [=]
// Время: 400ms

// ПРЕИМУЩЕСТВА ПАРАЛЛЕЛЬНОЙ:
// - Быстрее загрузка
// - Лучшее использование канала
// - Меньше блокировок

// HTTP/2 МУЛЬТИПЛЕКСИРОВАНИЕ:
// - Несколько запросов в одном соединении
// - Параллельная обработка
// - Нет блокировок на уровне соединений`
      },
      {
        title: 'Поиск узких мест',
        code: `// УЗКИЕ МЕСТА В ВОДОПАДЕ:

// 1. ДОЛГИЙ ЗАПРОС:
// API:      [========================]
// Время: 2000ms
// Решение: оптимизировать сервер, кешировать

// 2. МНОГО БЛОКИРОВОК:
// HTML:     [========]
// CSS:      [серый серый серый][====]
// JS:       [серый серый серый серый серый][==]
// Решение: async/defer, preload

// 3. ПОСЛЕДОВАТЕЛЬНАЯ ЗАГРУЗКА:
// Resource1: [==]
// Resource2:    [==]
// Resource3:        [==]
// Решение: HTTP/2, параллельная загрузка

// 4. ДОЛГИЙ TTFB:
// API:      [====TTFB====][==Download==]
//           ^^^^^^^^^^^^
//           800ms TTFB
// Решение: оптимизировать сервер, CDN

// 5. БОЛЬШОЙ РАЗМЕР:
// Image:    [========Download========]
// Размер: 5MB
// Решение: сжать, использовать WebP, lazy loading`
      },
      {
        title: 'Оптимизация на основе водопада',
        code: `// АНАЛИЗ ВОДОПАДА → ОПТИМИЗАЦИЯ:

// ПРОБЛЕМА: CSS блокирует рендеринг
// РЕШЕНИЕ:
// - Inline критический CSS
// - Preload основного CSS
<link rel="preload" href="/style.css" as="style">

// ПРОБЛЕМА: JS блокирует парсинг
// РЕШЕНИЕ:
// - Использовать defer
<script src="/app.js" defer></script>
// - Или async для некритического
<script src="/analytics.js" async></script>

// ПРОБЛЕМА: Последовательная загрузка изображений
// РЕШЕНИЕ:
// - HTTP/2 (мультиплексирование)
// - Prefetch для следующих страниц
<link rel="prefetch" href="/next-page.html">

// ПРОБЛЕМА: Долгий TTFB API
// РЕШЕНИЕ:
// - Кешировать ответы
// - Оптимизировать сервер
// - Использовать CDN

// ПРОБЛЕМА: Большие ресурсы
// РЕШЕНИЕ:
// - Сжимать (Gzip, Brotli)
// - Минифицировать
// - Использовать современные форматы`
      }
    ],
    relatedTopics: ['network-devtools', 'network-timing', 'resource-loading']
  }
];
