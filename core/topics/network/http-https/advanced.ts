import { Topic } from '../../../types';

export const NETWORK_HTTP_HTTPS_ADVANCED_TOPICS: Topic[] = [
  {
    id: 'http-caching-advanced',
    title: 'HTTP-кэширование (Advanced)',
    difficulty: 'advanced',
    description: 'Продвинутое HTTP-кэширование включает детальное понимание stale-while-revalidate, стратегий кэширования для разных сценариев (API, статика, HTML), проблем cache poisoning и инвалидации. Senior-разработчик должен уметь выбирать оптимальные стратегии кэширования, решать проблемы рассинхронизации кэша и оптимизировать производительность через правильное кэширование.',
    keyPoints: [
      'Stale-while-revalidate: использование устаревшего кэша сразу, обновление в фоне, улучшает воспринимаемую производительность.',
      'Стратегии кэширования: cache-first для статики, network-first для динамики, stale-while-revalidate для компромисса.',
      'Cache poisoning: проблема подмены кэша злоумышленниками, решается через валидацию и безопасные заголовки.',
      'Инвалидация кэша: версионирование файлов, изменение URL, Cache-Control заголовки, проблемы рассинхронизации.',
      'Уровни кэша: браузер → прокси → CDN → сервер, каждый уровень имеет свои правила и проблемы.',
      'Оптимизация: правильная стратегия для каждого типа ресурса критична для производительности и актуальности данных.'
    ],
    tags: ['networks', 'http', 'caching', 'performance', 'stale-while-revalidate', 'cache-poisoning', 'advanced'],
    examples: [
      {
        title: 'Stale-while-revalidate',
        code: `// STALE-WHILE-REVALIDATE: использовать устаревший кэш сразу, обновлять в фоне

// Заголовок:
Cache-Control: max-age=3600, stale-while-revalidate=86400

// ПОВЕДЕНИЕ:
// 1. Ресурс кэширован на 1 час (max-age=3600)
// 2. После истечения: использовать кэш ещё 24 часа (stale-while-revalidate=86400)
// 3. Параллельно: запросить обновление с сервера
// 4. При следующем запросе: использовать обновлённый кэш

// ПРИМЕР:
// Запрос 1 (0:00): загружается с сервера, кэшируется
// Запрос 2 (0:30): из кэша (свежий)
// Запрос 3 (1:30): из кэша (stale) + запрос на обновление в фоне
// Запрос 4 (2:00): из обновлённого кэша

// ПРЕИМУЩЕСТВА:
// - Мгновенный ответ (из кэша)
// - Актуальные данные (обновление в фоне)
// - Лучший UX (нет задержки)

// ПРИМЕНЕНИЕ:
// - API-ответы, которые могут быть немного устаревшими
// - Контент, который обновляется редко
// - Когда важна скорость, а не абсолютная актуальность`
      },
      {
        title: 'Стратегии кэширования для разных сценариев',
        code: `// 1. СТАТИЧЕСКИЕ РЕСУРСЫ (CSS, JS, изображения)
Cache-Control: public, max-age=31536000, immutable
// - Кэшируются на 1 год
// - Не меняются (имя файла с хешем)
// - Кэшируются везде (CDN, прокси)

// 2. HTML СТРАНИЦЫ
Cache-Control: no-cache
// - Всегда проверять свежесть
// - Может обновляться часто
// - Важна актуальность

// ИЛИ для SSG:
Cache-Control: public, max-age=3600, stale-while-revalidate=86400
// - Кэшируется на 1 час
// - Обновляется в фоне

// 3. API-ОТВЕТЫ (динамические данные)
Cache-Control: private, max-age=60, stale-while-revalidate=300
// - Кэшируется на 1 минуту (только в браузере)
// - Может быть устаревшим 5 минут
// - Персональные данные (private)

// 4. API-ОТВЕТЫ (публичные данные)
Cache-Control: public, max-age=300, stale-while-revalidate=3600
// - Кэшируется на 5 минут
// - Может быть устаревшим 1 час
// - Публичные данные (public)

// 5. ЧУВСТВИТЕЛЬНЫЕ ДАННЫЕ
Cache-Control: no-store, no-cache, must-revalidate
// - Не кэшировать вообще
// - Всегда запрашивать с сервера
// - Банковские данные, персональная информация`
      },
      {
        title: 'Cache poisoning (отравление кэша)',
        code: `// ПРОБЛЕМА: злоумышленник может подменить кэш

// АТАКА:
// 1. Злоумышленник отправляет запрос с вредоносным контентом
// 2. Сервер кэширует вредоносный контент
// 3. Другие пользователи получают вредоносный контент из кэша

// ПРИМЕР:
// Злоумышленник: GET /api/users?user=<script>alert('XSS')</script>
// Сервер кэширует ответ
// Другие пользователи получают XSS из кэша

// ✅ ЗАЩИТА:
// 1. Валидация входных данных
// 2. Vary заголовок для разных параметров
Cache-Control: public, max-age=3600
Vary: User-Agent, Accept-Language
// Разные User-Agent → разные кэши

// 3. Кэшировать только безопасные запросы
// Не кэшировать запросы с параметрами
Cache-Control: no-cache
// Для /api/users?filter=... → не кэшировать

// 4. Использовать ETag для валидации
ETag: "abc123"
// Сервер проверяет ETag перед использованием кэша

// 5. Ограничить кэширование публичных данных
Cache-Control: private, max-age=60
// Только браузерный кэш, не прокси/CDN`
      },
      {
        title: 'Инвалидация кэша',
        code: `// ПРОБЛЕМА: как обновить кэш при изменении ресурса

// ✅ РЕШЕНИЕ 1: Версионирование в имени файла
// styles.v1.css → styles.v2.css
<link rel="stylesheet" href="/styles.v2.css">

// Преимущества:
// - Разные URL → новый кэш
// - Старый кэш остаётся (для старых страниц)
// - Простота

// ✅ РЕШЕНИЕ 2: Хеш в имени файла
// styles.a1b2c3d4.css (webpack/vite автоматически)
<link rel="stylesheet" href="/styles.a1b2c3d4.css">

// Преимущества:
// - Автоматическое обновление при изменении
// - Долгий кэш (immutable)
// - Нет проблем с рассинхронизацией

// ✅ РЕШЕНИЕ 3: Query параметры
// styles.css?v=2.0.1
<link rel="stylesheet" href="/styles.css?v=2.0.1">

// Недостатки:
// - Некоторые прокси не кэшируют с query
// - Может не работать на CDN

// ✅ РЕШЕНИЕ 4: Cache-Control с коротким max-age
Cache-Control: max-age=3600
// Кэш обновляется через час

// ✅ РЕШЕНИЕ 5: Инвалидация через API
// CDN API для инвалидации кэша
POST /cdn/purge
{ "urls": ["/styles.css", "/app.js"] }

// Проблемы:
// - Нужен доступ к CDN API
// - Может быть медленным`
      },
      {
        title: 'Проблемы рассинхронизации кэша',
        code: `// ПРОБЛЕМА: разные уровни кэша имеют разные версии

// СЦЕНАРИЙ:
// 1. Сервер обновляет ресурс
// 2. Браузерный кэш: старая версия (max-age=3600)
// 3. CDN кэш: старая версия (TTL=1h)
// 4. Прокси кэш: старая версия

// РЕЗУЛЬТАТ: пользователи видят разные версии

// ✅ РЕШЕНИЕ 1: Версионирование файлов
// styles.v1.css → styles.v2.css
// Разные URL → разные кэши
// Нет рассинхронизации

// ✅ РЕШЕНИЕ 2: Короткий max-age + revalidate
Cache-Control: max-age=60, must-revalidate
// Кэш обновляется часто
// Всегда проверяется свежесть

// ✅ РЕШЕНИЕ 3: ETag для валидации
ETag: "abc123"
// Каждый уровень проверяет ETag
// Если изменился → загружает новую версию

// ✅ РЕШЕНИЕ 4: Инвалидация всех уровней
// При обновлении:
// 1. Обновить файл на сервере
// 2. Инвалидировать CDN кэш
// 3. Изменить версию в HTML
// 4. Браузеры загрузят новую версию`
      },
      {
        title: 'Оптимизация кэширования для производительности',
        code: `// СТРАТЕГИЯ ДЛЯ МАКСИМАЛЬНОЙ ПРОИЗВОДИТЕЛЬНОСТИ:

// 1. СТАТИКА: агрессивное кэширование
Cache-Control: public, max-age=31536000, immutable
// - Кэш на 1 год
// - Имя файла с хешем
// - Не меняется

// 2. HTML: баланс между скоростью и актуальностью
Cache-Control: public, max-age=3600, stale-while-revalidate=86400
// - Кэш на 1 час
// - Может быть устаревшим 24 часа
// - Обновление в фоне

// 3. API (публичные данные): кэширование с обновлением
Cache-Control: public, max-age=300, stale-while-revalidate=3600
// - Кэш на 5 минут
// - Может быть устаревшим 1 час
// - Обновление в фоне

// 4. API (персональные данные): короткий кэш
Cache-Control: private, max-age=60
// - Кэш на 1 минуту
// - Только в браузере
// - Важна актуальность

// РЕЗУЛЬТАТ:
// - Статика: мгновенная загрузка из кэша
// - HTML: быстрая загрузка + актуальность
// - API: баланс скорости и актуальности
// - Лучшие метрики (LCP, TTI)`
      },
      {
        title: 'Мониторинг эффективности кэширования',
        code: `// ИЗМЕРЕНИЕ ЭФФЕКТИВНОСТИ КЭШИРОВАНИЯ:

// 1. CACHE HIT RATIO
// Процент запросов, обслуживаемых из кэша
const cacheHitRatio = (cacheHits / totalRequests) * 100;
// Цель: > 80% для статики

// 2. CACHE SIZE
// Размер кэша в браузере
// Chrome DevTools → Application → Cache Storage
// Проверить использование памяти

// 3. NETWORK TIMELINE
// Chrome DevTools → Network
// (disk cache) или (memory cache) в Size колонке
// Показывает, откуда загружен ресурс

// 4. LIGHTHOUSE
// Uses efficient cache policy
// Показывает ресурсы без кэширования
// Рекомендации по оптимизации

// 5. CDN МЕТРИКИ
// Cloudflare / CloudFront аналитика
// Cache hit ratio, bandwidth savings
// Показывает эффективность CDN кэша

// 6. REAL USER MONITORING
// Отслеживание cache hit ratio у пользователей
// Показывает реальную эффективность`
      },
      {
        title: 'Типичные ошибки кэширования',
        code: `// ❌ ОШИБКА 1: Кэширование с параметрами
Cache-Control: public, max-age=3600
// Для /api/users?filter=active
// Проблема: разные фильтры → один кэш
// Решение: Vary заголовок или no-cache

// ❌ ОШИБКА 2: Слишком долгий кэш
Cache-Control: public, max-age=31536000
// Для часто меняющихся ресурсов
// Проблема: устаревшие данные
// Решение: короткий max-age или версионирование

// ❌ ОШИБКА 3: Кэширование персональных данных
Cache-Control: public, max-age=3600
// Для /api/user/profile
// Проблема: данные одного пользователя видны другому
// Решение: private или no-store

// ❌ ОШИБКА 4: Нет инвалидации
Cache-Control: public, max-age=31536000
// Без версионирования файлов
// Проблема: старые версии в кэше
// Решение: версионирование или короткий max-age

// ❌ ОШИБКА 5: Кэширование ошибок
// 404 или 500 ответы кэшируются
// Проблема: ошибки показываются долго
// Решение: no-store для ошибок`
      }
    ],
    relatedTopics: ['http-caching', 'performance-caching', 'critical-rendering-path'],
    funFact: 'Stale-while-revalidate был добавлен в HTTP стандарт относительно недавно и стал популярным благодаря улучшению воспринимаемой производительности. Идея в том, чтобы показывать контент сразу (даже если немного устаревший), а обновлять в фоне. Это особенно важно для мобильных устройств с медленным интернетом, где задержка в 500ms заметна пользователю.',
    isFrontendEssential: true
  },
  {
    id: 'http-versions',
    title: 'HTTP/1.1 vs HTTP/2 vs HTTP/3',
    difficulty: 'advanced',
    description: 'HTTP эволюционировал от версии 1.1 к 2 и 3, решая проблемы производительности. HTTP/1.1 имеет ограничения: одно соединение на домен, head-of-line blocking. HTTP/2 добавляет мультиплексирование, приоритизацию и сжатие заголовков. HTTP/3 использует QUIC поверх UDP, устраняя head-of-line blocking на транспортном уровне. Понимание различий важно для оптимизации производительности.',
    keyPoints: [
      'HTTP/1.1: текстовый протокол, одно соединение на домен, head-of-line blocking, нет сжатия заголовков.',
      'HTTP/2: бинарный протокол, мультиплексирование потоков, приоритизация, сжатие заголовков (HPACK), server push.',
      'HTTP/3: QUIC поверх UDP, встроенный TLS 1.3, мультиплексирование без head-of-line blocking, быстрая установка соединения.',
      'Мультиплексирование: HTTP/2 и HTTP/3 позволяют несколько запросов в одном соединении.',
      'Head-of-line blocking: HTTP/1.1 и HTTP/2 страдают от блокировки на уровне TCP, HTTP/3 решает это через QUIC.',
      'Обратная совместимость: все версии работают параллельно, сервер выбирает версию через ALPN.'
    ],
    tags: ['networks', 'http', 'http2', 'http3', 'performance', 'quic', 'advanced'],
    examples: [
      {
        title: 'HTTP/1.1 — ограничения',
        code: `// HTTP/1.1 проблемы:
// 1. Одно соединение на домен (или несколько, но ограничено)
// 2. Head-of-line blocking
// 3. Нет сжатия заголовков
// 4. Текстовый протокол (больше overhead)

// Пример: загрузка 6 ресурсов
// Соединение 1: [запрос 1] → [ответ 1] → [запрос 2] → [ответ 2] → ...
// Каждый запрос ждёт завершения предыдущего

// Решение: множественные соединения (обычно 6 на домен)
// Соединение 1: [запрос 1] → [ответ 1]
// Соединение 2: [запрос 2] → [ответ 2]
// Соединение 3: [запрос 3] → [ответ 3]
// ... но это создаёт overhead на установку соединений`
      },
      {
        title: 'HTTP/2 — мультиплексирование',
        code: `// HTTP/2 преимущества:
// 1. Мультиплексирование: несколько запросов в одном соединении
// 2. Приоритизация потоков
// 3. Сжатие заголовков (HPACK)
// 4. Server Push (отправка ресурсов до запроса)
// 5. Бинарный протокол (меньше overhead)

// Пример: загрузка 6 ресурсов
// Одно соединение:
// [поток 1: запрос] [поток 2: запрос] [поток 3: запрос]
// [поток 1: ответ] [поток 2: ответ] [поток 3: ответ]
// Все потоки обрабатываются параллельно

// ПРОБЛЕМА: Head-of-line blocking на уровне TCP
// Если пакет потока 1 потерян, все потоки блокируются
// TCP гарантирует порядок, поэтому ждёт потерянный пакет`
      },
      {
        title: 'HTTP/3 — QUIC поверх UDP',
        code: `// HTTP/3 решает проблемы HTTP/2:
// 1. QUIC поверх UDP (нет head-of-line blocking TCP)
// 2. Встроенный TLS 1.3 (меньше round-trips)
// 3. Мультиплексирование на уровне QUIC
// 4. Быстрая установка соединения (0-RTT для повторных)

// Пример: загрузка 6 ресурсов
// QUIC-соединение:
// [поток 1: запрос] [поток 2: запрос] [поток 3: запрос]
// [поток 1: ответ] [поток 2: ответ] [поток 3: ответ]
// Если пакет потока 1 потерян:
// - Только поток 1 блокируется
// - Потоки 2, 3 продолжают работать

// УСТАНОВКА СОЕДИНЕНИЯ:
// HTTP/2: TCP (1 RTT) + TLS (2 RTT) = 3 RTT
// HTTP/3: QUIC с TLS (1 RTT) = 1 RTT
// Повторное: HTTP/3 может использовать 0-RTT`
      },
      {
        title: 'Сравнение производительности',
        code: `// ЗАГРУЗКА 100 РЕСУРСОВ:

// HTTP/1.1:
// - 6 соединений параллельно
// - Каждое соединение последовательно
// - Время: ~16.7 секунд (100/6 запросов последовательно)

// HTTP/2:
// - 1 соединение, мультиплексирование
// - Все запросы параллельно
// - Время: ~1.7 секунд (но head-of-line blocking при потере пакетов)

// HTTP/3:
// - 1 соединение, мультиплексирование
// - Все запросы параллельно
// - Время: ~1.7 секунд (без head-of-line blocking)

// РЕАЛЬНЫЙ МИР:
// - HTTP/2 лучше на стабильных сетях
// - HTTP/3 лучше на нестабильных (мобильные, Wi-Fi)
// - HTTP/1.1 всё ещё используется (старые клиенты/серверы)`
      },
      {
        title: 'Server Push в HTTP/2',
        code: `// Server Push: сервер отправляет ресурсы до запроса клиента
// Клиент запрашивает HTML
// Сервер отправляет HTML + CSS + JS (которые понадобятся)

// Пример:
// Клиент: GET /index.html
// Сервер: 
//   - Отправляет index.html
//   - Push: /style.css (Link: </style.css>; rel=preload)
//   - Push: /script.js (Link: </script.js>; rel=preload)

// ПРОБЛЕМЫ:
// - Сервер может отправить ресурсы, которые уже в кеше
// - Клиент может отменить push (RST_STREAM)
// - Сложно определить, что нужно push-ить

// ПРАКТИКА:
// - Server Push редко используется
// - Лучше использовать <link rel=preload> в HTML`
      },
      {
        title: 'Выбор версии протокола',
        code: `// Сервер и клиент договариваются через ALPN (Application-Layer Protocol Negotiation)
// Клиент отправляет список поддерживаемых протоколов:
// - h2 (HTTP/2)
// - h3 (HTTP/3)
// - http/1.1

// Сервер выбирает лучший поддерживаемый протокол

// ПРАКТИКА:
// - Поддержка HTTP/2: ~95% браузеров
// - Поддержка HTTP/3: ~80% браузеров (растёт)
// - Fallback: HTTP/2 → HTTP/1.1

// НАСТРОЙКА:
// Nginx: listen 443 ssl http2;
// Cloudflare: автоматически использует HTTP/3 если доступно
// Chrome: chrome://flags/#enable-quic`
      }
    ],
    relatedTopics: ['http-over-tcp', 'tls-handshake', 'performance-multiplexing'],
    isFrontendEssential: true
  },
  {
    id: 'tls-handshake',
    title: 'TLS-рукопожатие',
    difficulty: 'advanced',
    description: 'TLS-рукопожатие — процесс установки зашифрованного соединения между клиентом и сервером. Включает обмен сертификатами, согласование шифров, генерацию ключей. Классическое рукопожатие занимает 2 round-trips (RTT), TLS 1.3 оптимизирован до 1 RTT, а повторные соединения могут использовать 0-RTT. Понимание рукопожатия важно для оптимизации производительности HTTPS.',
    keyPoints: [
      'Классическое рукопожатие (TLS 1.2): ClientHello → ServerHello → KeyExchange → 2 RTT.',
      'TLS 1.3 оптимизация: объединение сообщений, 1 RTT для новых соединений.',
      '0-RTT: повторные соединения могут отправлять данные сразу, если сервер помнит ключи.',
      'Сертификаты: сервер отправляет цепочку сертификатов, клиент проверяет подпись CA.',
      'Шифры: согласование алгоритмов шифрования, хеширования, обмена ключами.',
      'Производительность: рукопожатие добавляет задержку, но современные оптимизации минимизируют её.'
    ],
    tags: ['networks', 'https', 'tls', 'ssl', 'security', 'performance', 'advanced'],
    examples: [
      {
        title: 'TLS 1.2 рукопожатие (2 RTT)',
        code: `// RTT 1: Клиент → Сервер
// ClientHello:
//   - Поддерживаемые версии TLS
//   - Поддерживаемые шифры
//   - Случайное число (Client Random)

// RTT 1: Сервер → Клиент
// ServerHello:
//   - Выбранная версия TLS
//   - Выбранный шифр
//   - Случайное число (Server Random)
// Certificate:
//   - Сертификат сервера
//   - Цепочка сертификатов
// ServerKeyExchange:
//   - Параметры для обмена ключами
// ServerHelloDone

// RTT 2: Клиент → Сервер
// ClientKeyExchange:
//   - Зашифрованный предмастер-ключ
// ChangeCipherSpec:
//   - Переход на зашифрованное соединение
// Finished:
//   - Проверка целостности

// RTT 2: Сервер → Клиент
// ChangeCipherSpec
// Finished

// ИТОГО: 2 RTT до первого байта данных`
      },
      {
        title: 'TLS 1.3 рукопожатие (1 RTT)',
        code: `// TLS 1.3 оптимизирован:
// - Объединение сообщений
// - Удалены ненужные шаги
// - Более эффективный обмен ключами

// RTT 1: Клиент → Сервер
// ClientHello:
//   - Поддерживаемые версии (только 1.3)
//   - Поддерживаемые шифры
//   - Client Random
//   - Предполагаемые параметры ключа

// RTT 1: Сервер → Клиент
// ServerHello:
//   - Выбранная версия (1.3)
//   - Выбранный шифр
//   - Server Random
//   - Параметры ключа
// Certificate:
//   - Сертификат сервера
//   - Цепочка сертификатов
// CertificateVerify:
//   - Подпись сертификата
// Finished:
//   - Проверка целостности

// Клиент вычисляет ключи и отправляет:
// ChangeCipherSpec
// Finished

// ИТОГО: 1 RTT до первого байта данных`
      },
      {
        title: '0-RTT для повторных соединений',
        code: `// TLS 1.3 поддерживает 0-RTT:
// Клиент может отправить данные сразу,
// если сервер помнит предыдущее соединение

// ПЕРВОЕ СОЕДИНЕНИЕ:
// Клиент → Сервер: ClientHello
// Сервер → Клиент: ServerHello + сертификат
// Сервер сохраняет ключи (ticket)

// ПОВТОРНОЕ СОЕДИНЕНИЕ:
// Клиент → Сервер: ClientHello + Early Data (данные сразу)
// Сервер проверяет ticket и принимает данные
// Сервер → Клиент: ServerHello + Finished

// ИТОГО: 0 RTT до первого байта данных

// ОГРАНИЧЕНИЯ:
// - Только для безопасных запросов (GET, безопасные заголовки)
// - Сервер может отклонить 0-RTT и запросить полное рукопожатие
// - Риск replay-атак (повторная отправка перехваченных данных)`
      },
      {
        title: 'Проверка сертификата',
        code: `// Клиент проверяет сертификат:
// 1. Сертификат действителен (не истёк)
// 2. Сертификат подписан доверенным CA
// 3. Доменное имя совпадает (CN или SAN)
// 4. Сертификат не отозван (OCSP или CRL)

// ЦЕПОЧКА СЕРТИФИКАТОВ:
// example.com (сертификат сервера)
//   ↓ подписан
// Intermediate CA (промежуточный CA)
//   ↓ подписан
// Root CA (корневой CA, встроен в браузер)

// Браузер проверяет всю цепочку до корневого CA

// ОШИБКИ:
// - Сертификат истёк → "Ваше соединение не защищено"
// - Неизвестный CA → предупреждение
// - Несовпадение домена → ошибка`
      },
      {
        title: 'Влияние на производительность',
        code: `// ЗАДЕРЖКА TLS-РУКОПОЖАТИЯ:
// TLS 1.2: ~200-300ms (2 RTT)
// TLS 1.3: ~100-150ms (1 RTT)
// TLS 1.3 0-RTT: ~0ms (для повторных)

// ОПТИМИЗАЦИИ:
// 1. TLS Session Resumption
//    - Сохранение сессии для повторного использования
//    - Session ID или Session Tickets

// 2. HTTP/2 Server Push
//    - Отправка ресурсов до запроса
//    - Компенсирует задержку рукопожатия

// 3. Preconnect
//    - <link rel="preconnect" href="https://api.example.com">
//    - Устанавливает соединение заранее

// 4. CDN с близкими серверами
//    - Уменьшает RTT (задержку сети)`
      }
    ],
    relatedTopics: ['https-basics', 'http-versions', 'performance-prefetch'],
    isFrontendEssential: true
  }
];
