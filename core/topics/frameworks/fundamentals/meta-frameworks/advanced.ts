import { Topic } from '../../../../types';

export const META_FRAMEWORKS_ADVANCED_TOPICS: Topic[] = [
  {
    id: 'frameworks-meta-frameworks-vendor-lock-in',
    title: 'Vendor lock-in',
    difficulty: 'advanced',
    description: 'Vendor lock-in — это зависимость от конкретного мета-фреймворка, которая усложняет миграцию на другой. Мета-фреймворки создают свою экосистему: file-based routing, data fetching, API routes, оптимизации. Переход на другой мета-фреймворк требует переписывания значительной части кода.\n\nПризнаки vendor lock-in: использование специфичных API (getServerSideProps, asyncData), зависимость от структуры файлов, использование платформенных возможностей (Vercel для Next.js). Это создаёт зависимость от конкретного мета-фреймворка и его экосистемы.\n\nСтратегии снижения vendor lock-in: использование стандартных API где возможно, абстракция платформенных возможностей, модульная архитектура. Но полное избежание vendor lock-in невозможно: мета-фреймворки создают свою экосистему, и это их преимущество.\n\nВ 2026 vendor lock-in стал осознанным выбором: разработчики понимают зависимость от мета-фреймворка, но выбирают его за преимущества (скорость разработки, производительность). Понимание vendor lock-in критично для принятия решений о выборе мета-фреймворка.',
    keyPoints: [
      'Vendor lock-in: зависимость от конкретного мета-фреймворка',
      'Признаки: специфичные API, структура файлов, платформенные возможности',
      'Усложняет миграцию на другой мета-фреймворк',
      'Стратегии снижения: стандартные API, абстракция, модульная архитектура',
      'Полное избежание невозможно: мета-фреймворки создают свою экосистему',
      'Осознанный выбор в 2026: преимущества vs зависимость'
    ],
    funFact: 'Vendor lock-in — это классическая проблема в разработке программного обеспечения. В контексте мета-фреймворков это стало особенно актуальным с ростом популярности Next.js и его интеграции с Vercel платформой.',
    tags: ['frameworks', 'meta-frameworks', 'vendor-lock-in', 'migration', 'advanced', 'strategy'],
    examples: [
      {
        title: 'Признаки vendor lock-in',
        code: `// Next.js: специфичные API
export async function getServerSideProps() {
  // Специфично для Next.js
  // Не работает в других мета-фреймворках
  return { props: { data } };
}

// Структура файлов
// pages/api/users.js → специфично для Next.js
// Другие мета-фреймворки используют другую структуру

// Платформенные возможности
// Vercel Edge Functions → специфично для Vercel
// Не работает на других платформах

// Проблема: миграция требует переписывания кода`
      },
      {
        title: 'Стратегии снижения vendor lock-in',
        code: `// 1. Использование стандартных API
// Вместо getServerSideProps использовать стандартные хуки
'use client';
export default function Page() {
  const { data } = useQuery(['data'], fetchData);
  // Стандартный API, работает везде
}

// 2. Абстракция платформенных возможностей
// Создать слой абстракции
const dataFetcher = {
  server: () => getServerSideProps(),
  client: () => useQuery(['data'], fetchData)
};

// 3. Модульная архитектура
// Разделить бизнес-логику и платформенный код
// Бизнес-логика независима от мета-фреймворка

// Преимущество: легче мигрировать
// Недостаток: больше кода, меньше использование возможностей`
      },
      {
        title: 'Осознанный выбор',
        code: `// Vendor lock-in vs Преимущества
// Преимущества мета-фреймворка:
// - Скорость разработки
// - Производительность из коробки
// - Экосистема и инструменты

// Стоимость vendor lock-in:
// - Зависимость от мета-фреймворка
// - Сложность миграции
// - Ограничения платформы

// Решение: осознанный выбор
// - Оценить преимущества vs стоимость
// - Выбрать мета-фреймворк под долгосрочные цели
// - Понимать зависимость и планировать миграцию при необходимости`
      }
    ],
    relatedTopics: ['frameworks-meta-frameworks-when-excessive', 'frameworks-evolution-criteria'],
    isFrontendEssential: false
  },
  {
    id: 'frameworks-meta-frameworks-when-excessive',
    title: 'Когда избыточен',
    difficulty: 'advanced',
    description: 'Мета-фреймворк может быть избыточным когда приложение не использует его основные возможности: SSR/SSG не нужен, file-based routing не подходит, API routes не используются. В таких случаях базовый фреймворк + библиотека роутинга может быть проще и легче.\n\nПризнаки избыточности: использование только CSR (не нужен SSR/SSG), сложная структура маршрутов (file-based routing не подходит), отдельный бэкенд (не нужны API routes), маленькое приложение (overhead мета-фреймворка не оправдан). В этих случаях мета-фреймворк добавляет сложность без выгоды.\n\nАльтернативы: базовый фреймворк (React, Vue) + библиотека роутинга (React Router, Vue Router) + настройка сборки (Vite, Webpack). Это даёт больше контроля, но требует больше настройки. Выбор зависит от требований: нужны ли возможности мета-фреймворка или достаточно базового фреймворка.\n\nВ 2026 понимание когда мета-фреймворк избыточен критично для принятия решений. Не всегда нужен мета-фреймворк: иногда базовый фреймворк + библиотеки достаточно. Понимание trade-offs помогает выбрать правильный инструмент.',
    keyPoints: [
      'Мета-фреймворк избыточен когда не используются основные возможности',
      'Признаки: только CSR, сложная структура маршрутов, отдельный бэкенд, маленькое приложение',
      'Добавляет сложность без выгоды',
      'Альтернатива: базовый фреймворк + библиотека роутинга + настройка сборки',
      'Выбор зависит от требований: нужны ли возможности мета-фреймворка',
      'Понимание trade-offs критично для выбора инструмента'
    ],
    funFact: 'Многие разработчики используют мета-фреймворки по умолчанию, даже когда они не нужны. Это создаёт избыточную сложность. Понимание когда мета-фреймворк избыточен помогает выбрать правильный инструмент под задачу.',
    tags: ['frameworks', 'meta-frameworks', 'decision-making', 'trade-offs', 'advanced', 'strategy'],
    examples: [
      {
        title: 'Когда мета-фреймворк избыточен',
        code: `// ❌ Избыточно: только CSR, не нужен SSR/SSG
// Next.js для SPA без SSR
// Используется только клиентский рендеринг
// Overhead мета-фреймворка не оправдан

// ✅ Альтернатива: React + React Router
import { BrowserRouter } from 'react-router-dom';

function App() {
  return (
    <BrowserRouter>
      <Routes>
        <Route path="/" element={<Home />} />
      </Routes>
    </BrowserRouter>
  );
}

// Проще, меньше overhead
// Преимущество: больше контроля, меньше сложности`
      },
      {
        title: 'Сложная структура маршрутов',
        code: `// ❌ Избыточно: сложная структура маршрутов
// File-based routing не подходит для:
// - Динамических маршрутов
// - Условных маршрутов
// - Сложной логики роутинга

// ✅ Альтернатива: config-based routing
const routes = [
  {
    path: '/',
    component: Home,
    children: [
      { path: 'dashboard', component: Dashboard, guard: authGuard },
      { path: 'admin', component: Admin, guard: adminGuard }
    ]
  }
];

// Больше контроля над роутингом
// Преимущество: гибкость для сложных случаев`
      },
      {
        title: 'Отдельный бэкенд',
        code: `// ❌ Избыточно: отдельный бэкенд
// Next.js API routes не используются
// Есть отдельный бэкенд на Node.js/Python/etc
// API routes добавляют сложность без выгоды

// ✅ Альтернатива: React + отдельный бэкенд
// Фронтенд: React + React Router
// Бэкенд: отдельный сервер
// Коммуникация: REST/GraphQL API

// Преимущество: разделение ответственности
// Фронтенд и бэкенд независимы
// Легче масштабировать отдельно`
      }
    ],
    relatedTopics: ['frameworks-meta-frameworks-vendor-lock-in', 'frameworks-evolution-criteria'],
    isFrontendEssential: false
  }
];
