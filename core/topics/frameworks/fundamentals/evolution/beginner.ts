import { Topic } from '../../../../types';

export const EVOLUTION_BEGINNER_TOPICS: Topic[] = [
  {
    id: 'frameworks-evolution-jquery-to-components',
    title: 'От jQuery к компонентам',
    difficulty: 'beginner',
    description: 'В начале 2000-х веб-разработка строилась на прямом манипулировании DOM через jQuery. Каждое изменение интерфейса требовало явных команд: найти элемент, изменить его содержимое, обновить стили. Это работало для простых сайтов, но в сложных приложениях превращалось в кошмар: код разбросан по всему проекту, сложно отследить зависимости, легко допустить ошибку.\n\nПроблема усугублялась с ростом приложений: один и тот же элемент мог обновляться из десятка мест, синхронизация данных и UI становилась непредсказуемой. Разработчики тратили больше времени на отладку, чем на добавление функционала.\n\nРешение пришло с идеей компонентов: вместо работы с отдельными элементами DOM, разработчики начали думать о переиспользуемых блоках интерфейса. Каждый компонент инкапсулирует свою логику, состояние и представление, что делает код предсказуемым и поддерживаемым.\n\nВ 2026 компонентная модель стала стандартом де-факто. Все современные фреймворки (React, Vue, Angular, Svelte) построены на этой идее. Даже нативные платформы (Flutter, SwiftUI) используют компонентный подход, что подтверждает правильность выбранного пути.',
    keyPoints: [
      'jQuery требовал явного манипулирования DOM: найти элемент, изменить, обновить',
      'В сложных приложениях код разбросан, синхронизация данных и UI непредсказуема',
      'Компоненты инкапсулируют логику, состояние и представление в одном месте',
      'Компонентная модель делает код предсказуемым и переиспользуемым',
      'Все современные фреймворки построены на компонентном подходе',
      'Переход от jQuery к компонентам — это переход от императивного к декларативному стилю'
    ],
    funFact: 'jQuery был создан в 2006 году и до сих пор используется на 77% всех сайтов в интернете, несмотря на то, что современные фреймворки полностью заменили его в новых проектах.',
    tags: ['frameworks', 'history', 'jquery', 'components', 'evolution', 'basics', 'fundamentals'],
    examples: [
      {
        title: 'jQuery: императивный подход',
        code: `// jQuery: явное манипулирование DOM
$('#counter').text(count);
$('#button').on('click', function() {
  count++;
  $('#counter').text(count); // Нужно помнить обновить вручную
  $('#status').text(count > 10 ? 'Много' : 'Мало'); // И здесь тоже
});

// Проблема: если забыть обновить один элемент, UI рассинхронизируется`
      },
      {
        title: 'Компонентный подход: декларативный',
        code: `// React/Vue: декларативный подход
function Counter() {
  const [count, setCount] = useState(0);
  
  return (
    <div>
      <p>{count}</p>
      <p>{count > 10 ? 'Много' : 'Мало'}</p>
      <button onClick={() => setCount(count + 1)}>
        Увеличить
      </button>
    </div>
  );
}

// Преимущество: UI автоматически синхронизируется с данными
// Не нужно помнить обновлять каждый элемент вручную`
      },
      {
        title: 'Проблема синхронизации в jQuery',
        code: `// jQuery: легко забыть обновить элемент
let user = { name: 'Иван', age: 25 };

// Обновляем имя
$('#name').text(user.name);

// Обновляем возраст
$('#age').text(user.age);

// Забыли обновить статус!
// $('#status').text(user.age >= 18 ? 'Взрослый' : 'Ребенок');

// В компонентах это решается автоматически:
function UserProfile({ user }) {
  return (
    <div>
      <p>{user.name}</p>
      <p>{user.age}</p>
      <p>{user.age >= 18 ? 'Взрослый' : 'Ребенок'}</p>
    </div>
  );
}`
      }
    ],
    relatedTopics: ['frameworks-evolution-library-vs-framework', 'frameworks-component-model-atom'],
    isFrontendEssential: true
  },
  {
    id: 'frameworks-evolution-library-vs-framework',
    title: 'Библиотека vs Фреймворк vs Мета-фреймворк',
    difficulty: 'beginner',
    description: 'Понимание различий между библиотекой, фреймворком и мета-фреймворком критично для выбора правильного инструмента. Библиотека — это набор готовых функций, которые вы вызываете по мере необходимости. Вы контролируете поток выполнения, библиотека просто предоставляет инструменты.\n\nФреймворк — это больше, чем библиотека. Он определяет структуру приложения и контролирует поток выполнения. Вы пишете код, который фреймворк вызывает в нужные моменты. Это инверсия контроля: не вы вызываете фреймворк, а фреймворк вызывает ваш код.\n\nМета-фреймворк — это фреймворк, построенный поверх другого фреймворка. Он добавляет дополнительные возможности: роутинг, серверный рендеринг, оптимизацию сборки. Примеры: Next.js (для React), Nuxt (для Vue), SvelteKit (для Svelte).\n\nВыбор зависит от задач: библиотека даёт гибкость, фреймворк — структуру и стандарты, мета-фреймворк — готовое решение для полного стека. В 2026 мета-фреймворки становятся стандартом для новых проектов, так как они решают большинство типовых задач из коробки.',
    keyPoints: [
      'Библиотека: набор функций, вы контролируете когда их вызывать (например, lodash, axios)',
      'Фреймворк: определяет структуру, контролирует поток выполнения (React, Vue, Angular)',
      'Мета-фреймворк: фреймворк поверх фреймворка, добавляет роутинг, SSR, оптимизации (Next.js, Nuxt)',
      'Библиотека = вы вызываете код, Фреймворк = код вызывает вас (инверсия контроля)',
      'Выбор зависит от задач: гибкость vs структура vs готовое решение',
      'Мета-фреймворки становятся стандартом для новых проектов в 2026'
    ],
    funFact: 'Термин "инверсия контроля" (Inversion of Control) был популяризирован в 2004 году Мартином Фаулером, хотя сама концепция использовалась в программировании с 1980-х годов.',
    tags: ['frameworks', 'basics', 'library', 'framework', 'meta-framework', 'fundamentals', 'concepts'],
    examples: [
      {
        title: 'Библиотека: вы контролируете вызовы',
        code: `// Библиотека lodash: вы решаете когда использовать
import _ from 'lodash';

const users = [{ name: 'Иван', age: 25 }, { name: 'Мария', age: 30 }];

// Вы вызываете функцию когда нужно
const sorted = _.sortBy(users, 'age');
const filtered = _.filter(users, u => u.age > 25);

// Поток выполнения контролируете вы`
      },
      {
        title: 'Фреймворк: он контролирует вызовы',
        code: `// React: фреймворк вызывает ваш компонент
function App() {
  // React решает когда вызвать этот компонент
  // React решает когда обновить UI
  // Вы просто описываете что должно быть
  
  return <div>Привет</div>;
}

// Вы не вызываете React, React вызывает вас
// Это инверсия контроля`
      },
      {
        title: 'Мета-фреймворк: готовое решение',
        code: `// Next.js (мета-фреймворк для React)
// Автоматически добавляет:
// - File-based routing (роутинг по файлам)
// - Server-side rendering (SSR)
// - Оптимизацию изображений
// - API routes

// pages/index.js - автоматически становится маршрутом /
export default function Home() {
  return <h1>Главная</h1>;
}

// pages/about.js - автоматически становится маршрутом /about
export default function About() {
  return <h1>О нас</h1>;
}

// Всё работает из коробки, не нужно настраивать роутинг вручную`
      }
    ],
    relatedTopics: ['frameworks-evolution-jquery-to-components', 'frameworks-meta-frameworks-nextjs-nuxt'],
    isFrontendEssential: true
  },
  {
    id: 'frameworks-evolution-declarative-ui',
    title: 'Declarative UI = f(state)',
    difficulty: 'beginner',
    description: 'Фундаментальная идея современных фреймворков: интерфейс — это функция от состояния. Вместо того чтобы вручную обновлять каждый элемент DOM при изменении данных, вы описываете как состояние преобразуется в интерфейс. Фреймворк сам отслеживает изменения и обновляет UI.\n\nЭто математическая концепция: UI = f(state), где f — функция преобразования, state — текущее состояние приложения. Если состояние не изменилось, интерфейс остаётся прежним. Если изменилось — функция пересчитывается и UI обновляется.\n\nПреимущество этого подхода в предсказуемости: при одном и том же состоянии вы всегда получите одинаковый интерфейс. Нет скрытых зависимостей, нет рассинхронизации, нет необходимости помнить обновлять элементы вручную.\n\nВ 2026 эта идея стала настолько естественной, что разработчики даже не задумываются о ней. Но понимание этой концепции критично для эффективной работы с любым современным фреймворком.',
    keyPoints: [
      'UI = f(state): интерфейс это функция от состояния',
      'Вместо ручного обновления DOM описываете преобразование состояния в UI',
      'Фреймворк автоматически отслеживает изменения и обновляет интерфейс',
      'Предсказуемость: одинаковое состояние = одинаковый интерфейс',
      'Нет скрытых зависимостей и рассинхронизации',
      'Эта концепция лежит в основе всех современных фреймворков'
    ],
    funFact: 'Идея "UI как функция от состояния" пришла из функционального программирования. В математике функция всегда возвращает одинаковый результат для одинаковых входных данных — это свойство называется "чистота функции" (pure function).',
    tags: ['frameworks', 'declarative', 'state', 'ui', 'functional', 'basics', 'fundamentals', 'concepts'],
    examples: [
      {
        title: 'Императивный подход: ручное обновление',
        code: `// Императивный: вы вручную обновляете каждый элемент
let count = 0;

function updateUI() {
  document.getElementById('counter').textContent = count;
  document.getElementById('status').textContent = count > 10 ? 'Много' : 'Мало';
  document.getElementById('button').disabled = count >= 20;
}

// Нужно помнить вызывать updateUI() после каждого изменения
count++;
updateUI(); // Легко забыть!
count++;
// Забыли updateUI() - UI рассинхронизирован`
      },
      {
        title: 'Декларативный: UI = f(state)',
        code: `// Декларативный: описываете преобразование
function Counter({ count }) {
  // UI = f(state), где state = { count }
  return (
    <div>
      <p>{count}</p>
      <p>{count > 10 ? 'Много' : 'Мало'}</p>
      <button disabled={count >= 20}>
        Увеличить
      </button>
    </div>
  );
}

// Фреймворк автоматически обновит UI при изменении count
// Не нужно помнить вызывать updateUI()`
      },
      {
        title: 'Чистая функция: предсказуемость',
        code: `// Чистая функция: одинаковый вход = одинаковый выход
function renderUser(user) {
  // Для { name: 'Иван', age: 25 } всегда вернёт одинаковый UI
  return (
    <div>
      <h1>{user.name}</h1>
      <p>Возраст: {user.age}</p>
      <p>Статус: {user.age >= 18 ? 'Взрослый' : 'Ребенок'}</p>
    </div>
  );
}

// Преимущество: легко тестировать, легко отлаживать
// Нет скрытых зависимостей, нет побочных эффектов`
      }
    ],
    relatedTopics: ['frameworks-evolution-jquery-to-components', 'frameworks-reactivity-auto-update'],
    isFrontendEssential: false
  }
];
