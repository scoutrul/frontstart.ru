import { Topic } from '../../../../types';

export const INTERVIEWS_BEGINNER_TOPICS: Topic[] = [
  {
    id: 'frameworks-interviews-typical-questions',
    title: 'Типовые вопросы',
    difficulty: 'beginner',
    description: 'Типовые вопросы по фреймворкам на собеседованиях включают: что такое Virtual DOM, как работает реактивность, в чём разница между библиотекой и фреймворком, как работает гидратация, что такое компонент. Эти вопросы проверяют понимание основных концепций, а не знание конкретного API.\n\nПодход к ответам: объяснять концепцию, а не перечислять API методы. Например, вместо "Virtual DOM это объект" объяснить "Virtual DOM это абстракция над DOM для эффективного обновления". Это показывает понимание, а не заучивание.\n\nСтруктура ответа: проблема (что решает концепция), решение (как решает), примеры (как используется), trade-offs (плюсы и минусы). Это демонстрирует системное мышление и понимание компромиссов.\n\nВ 2026 типовые вопросы остаются актуальными, но добавляются вопросы про современные подходы: Server Components, компиляцию, частичную гидратацию. Понимание типовых вопросов и как на них отвечать критично для успешного прохождения собеседований.',
    keyPoints: [
      'Типовые вопросы: Virtual DOM, реактивность, библиотека vs фреймворк, гидратация',
      'Подход: объяснять концепцию, а не перечислять API',
      'Структура ответа: проблема → решение → примеры → trade-offs',
      'Показывает понимание, а не заучивание',
      'Добавляются вопросы про современные подходы в 2026',
      'Критично для успешного прохождения собеседований'
    ],
    funFact: 'Типовые вопросы по фреймворкам стали стандартом на собеседованиях с ростом популярности React, Vue и Angular. Они проверяют не только знание API, но и понимание концепций, что важно для работы в команде.',
    tags: ['frameworks', 'interviews', 'questions', 'basics', 'fundamentals', 'core'],
    examples: [
      {
        title: 'Типовой вопрос: Virtual DOM',
        code: `// ❌ Плохой ответ: перечисление фактов
// "Virtual DOM это объект, который представляет DOM"

// ✅ Хороший ответ: объяснение концепции
// "Virtual DOM решает проблему эффективного обновления DOM.
// Проблема: прямое обновление DOM дорогое.
// Решение: создаём легковесную копию DOM в памяти,
// сравниваем её со старой версией, применяем только изменения.
// Преимущество: не нужно думать о том, что обновлять.
// Недостаток: overhead на сравнение."

// Структура:
// 1. Проблема (что решает)
// 2. Решение (как решает)
// 3. Примеры (как используется)
// 4. Trade-offs (плюсы и минусы)`
      },
      {
        title: 'Типовой вопрос: реактивность',
        code: `// ❌ Плохой ответ: перечисление API
// "Реактивность это useState, useEffect"

// ✅ Хороший ответ: объяснение концепции
// "Реактивность решает проблему синхронизации данных и UI.
// Проблема: нужно вручную обновлять DOM при изменении данных.
// Решение: система автоматически отслеживает изменения
// и обновляет интерфейс.
// Пример: изменили переменную → интерфейс обновился автоматически.
// Trade-offs: автоматизация vs overhead на отслеживание."

// Показывает понимание концепции
// Не просто знание API`
      },
      {
        title: 'Структура ответа',
        code: `// Структура ответа на типовой вопрос:
// 1. Проблема
// "До реактивности нужно было вручную обновлять DOM..."

// 2. Решение
// "Реактивность автоматизирует это..."

// 3. Примеры
// "Например, в React useState автоматически..."

// 4. Trade-offs
// "Преимущество: автоматизация.
// Недостаток: overhead на отслеживание."

// Преимущество: показывает системное мышление
// Демонстрирует понимание компромиссов
// Не просто заучивание фактов`
      }
    ],
    relatedTopics: ['frameworks-interviews-understanding-vs-api', 'frameworks-interviews-architectural-solutions'],
    isFrontendEssential: true
  },
  {
    id: 'frameworks-interviews-understanding-vs-api',
    title: 'Понимание vs знание API',
    difficulty: 'beginner',
    description: 'На собеседованиях важно демонстрировать понимание концепций, а не только знание API. Понимание означает: знание почему концепция появилась, как она решает проблему, какие есть trade-offs. Знание API означает: знание методов и синтаксиса, но без понимания зачем они нужны.\n\nДемонстрация понимания: объяснять проблему, которую решает концепция, показывать trade-offs, приводить примеры использования, объяснять когда использовать и когда не использовать. Это показывает системное мышление и способность принимать решения.\n\nИзбегание заучивания: не перечислять методы API без контекста, не отвечать шаблонными фразами, не игнорировать trade-offs. Вместо этого объяснять концепцию в контексте проблемы, показывать понимание компромиссов, демонстрировать способность применять знания.\n\nВ 2026 на собеседованиях всё больше ценят понимание концепций, а не знание конкретного API. API может измениться, но понимание концепций остаётся актуальным. Понимание различия между пониманием и знанием API критично для успешного прохождения собеседований.',
    keyPoints: [
      'Понимание: знание почему, как решает проблему, trade-offs',
      'Знание API: знание методов и синтаксиса без понимания зачем',
      'Демонстрация понимания: объяснять проблему, показывать trade-offs, приводить примеры',
      'Избегать заучивания: не перечислять методы без контекста',
      'Ценят понимание концепций, а не знание конкретного API',
      'Критично для успешного прохождения собеседований'
    ],
    funFact: 'На собеседованиях в крупных компаниях (Google, Facebook, Microsoft) всё больше ценят понимание концепций, а не знание конкретного API. Это связано с тем, что API может измениться, но понимание концепций остаётся актуальным.',
    tags: ['frameworks', 'interviews', 'understanding', 'concepts', 'basics', 'fundamentals'],
    examples: [
      {
        title: 'Знание API vs Понимание',
        code: `// ❌ Знание API (заучивание):
// "useState это хук, который возвращает массив с значением и функцией.
// useEffect это хук для побочных эффектов.
// useMemo это хук для мемоизации."

// ✅ Понимание (концепция):
// "useState решает проблему состояния в функциональных компонентах.
// Проблема: функциональные компоненты не имели состояния.
// Решение: хук useState добавляет состояние.
// Trade-offs: простота vs ограничения (правила хуков).
// Пример: счётчик с useState автоматически обновляет UI."

// Показывает понимание концепции
// Не просто перечисление методов`
      },
      {
        title: 'Демонстрация понимания',
        code: `// Демонстрация понимания:
// 1. Объяснить проблему
// "До хуков функциональные компоненты не имели состояния..."

// 2. Показать решение
// "Хуки решают это через замыкания и связанный список..."

// 3. Показать trade-offs
// "Преимущество: простота использования.
// Недостаток: правила хуков (только на верхнем уровне)."

// 4. Привести примеры
// "Например, useState для счётчика..."

// 5. Объяснить когда использовать
// "Использовать когда нужен локальный state.
// Не использовать для глобального состояния."

// Преимущество: показывает системное мышление
// Демонстрирует способность принимать решения`
      },
      {
        title: 'Избегание заучивания',
        code: `// ❌ Заучивание (плохо):
// "Virtual DOM это объект.
// React использует Virtual DOM.
// Virtual DOM быстрее чем прямой DOM."

// ✅ Понимание (хорошо):
// "Virtual DOM решает проблему эффективного обновления DOM.
// Проблема: прямое обновление DOM дорогое и сложное.
// Решение: легковесная копия в памяти, сравнение, применение изменений.
// Trade-offs: простота разработки vs overhead на сравнение.
// Использовать когда: много обновлений, сложная структура.
// Не использовать когда: простые обновления, критична производительность."

// Показывает понимание концепции
// Демонстрирует способность анализировать`
      }
    ],
    relatedTopics: ['frameworks-interviews-typical-questions', 'frameworks-interviews-architectural-solutions'],
    isFrontendEssential: false
  }
];
