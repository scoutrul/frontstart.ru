import { Topic } from '../../../../types';

export const RENDERING_INTERMEDIATE_TOPICS: Topic[] = [
  {
    id: 'frameworks-rendering-ssr',
    title: 'SSR',
    difficulty: 'intermediate',
    description: 'SSR (Server-Side Rendering) — это рендеринг интерфейса на сервере. Сервер выполняет JavaScript, рендерит HTML с контентом, и отправляет готовый HTML браузеру. Браузер получает HTML с контентом сразу, что даёт быстрый First Contentful Paint (FCP) и отличное SEO.\n\nSSR решает проблемы CSR: быстрая первая загрузка (HTML с контентом сразу), отличное SEO (поисковики видят контент), меньше JavaScript на клиенте (рендеринг на сервере). Но SSR имеет стоимость: больше нагрузка на сервер, медленная навигация (нужен запрос к серверу для каждой страницы).\n\nГидратация — это процесс "оживления" статического HTML: после получения HTML браузер загружает JavaScript, который "подключается" к существующему HTML и делает его интерактивным. Это критично для SSR: HTML статичен, JavaScript делает его интерактивным.\n\nВ 2026 SSR стал стандартом для контентных сайтов через мета-фреймворки (Next.js, Nuxt). Они автоматизируют SSR, гидратацию и оптимизацию, делая SSR доступным без сложной настройки.',
    keyPoints: [
      'SSR: рендеринг на сервере, сервер отправляет HTML с контентом',
      'Быстрый FCP: HTML с контентом сразу',
      'Отличное SEO: поисковики видят контент',
      'Стоимость: больше нагрузка на сервер, медленная навигация',
      'Гидратация: "оживление" статического HTML через JavaScript',
      'Мета-фреймворки автоматизируют SSR в 2026'
    ],
    funFact: 'SSR существовал с самого начала веба, но стал популярным снова в 2010-х годах как решение проблем CSR. Next.js, созданный в 2016 году, популяризировал SSR для React, показав что можно комбинировать преимущества SSR и CSR.',
    tags: ['frameworks', 'rendering', 'ssr', 'server-side', 'hydration', 'intermediate', 'core'],
    examples: [
      {
        title: 'SSR: рендеринг на сервере',
        code: `// SSR: сервер рендерит HTML
// server.js
app.get('/', (req, res) => {
  // Сервер выполняет JavaScript
  const html = ReactDOMServer.renderToString(
    <App data={fetchData()} />
  );
  
  // Отправляет HTML с контентом
  res.send(\`
    <!DOCTYPE html>
    <html>
      <body>
        <div id="app">\${html}</div>
        <script src="app.js"></script>
      </body>
    </html>
  \`);
});

// Браузер получает:
<!DOCTYPE html>
<html>
<body>
  <div id="app">
    <h1>Привет</h1>
    <p>Контент уже здесь!</p>
  </div>
  <script src="app.js"></script>
</body>
</html>

// Преимущество: контент сразу, быстрый FCP`
      },
      {
        title: 'Гидратация',
        code: `// Гидратация: "оживление" статического HTML
// 1. Сервер отправляет HTML с контентом
<div id="app">
  <button>Кликни меня</button>
</div>

// 2. Браузер показывает HTML (статичный, не интерактивный)

// 3. Браузер загружает JavaScript

// 4. JavaScript "подключается" к HTML
ReactDOM.hydrate(<App />, document.getElementById('app'));

// 5. HTML становится интерактивным
// Кнопка теперь реагирует на клики

// Процесс гидратации:
// - React находит существующий HTML
// - "Подключается" к нему
// - Добавляет обработчики событий
// - Делает интерактивным`
      },
      {
        title: 'SSR vs CSR',
        code: `// SSR: преимущества и недостатки
// Преимущества:
// - Быстрый FCP (HTML с контентом сразу)
// - Отличное SEO (поисковики видят контент)
// - Меньше JavaScript на клиенте

// Недостатки:
// - Больше нагрузка на сервер
// - Медленная навигация (нужен запрос к серверу)
// - Сложнее кэширование

// CSR: преимущества и недостатки
// Преимущества:
// - Быстрая навигация после первой загрузки
// - Меньше нагрузка на сервер
// - Проще кэширование

// Недостатки:
// - Медленная первая загрузка
// - Плохое SEO
// - Больше JavaScript

// Гибридный подход: SSR для первой загрузки, CSR для навигации`
      }
    ],
    relatedTopics: ['frameworks-rendering-hydration', 'frameworks-rendering-ssg', 'react-server-components', 'frameworks-meta-frameworks-data-fetching'],
    isFrontendEssential: true
  },
  {
    id: 'frameworks-rendering-hydration',
    title: 'Гидратация',
    difficulty: 'intermediate',
    description: 'Гидратация — это процесс "оживления" статического HTML через JavaScript. После получения HTML с сервера браузер загружает JavaScript, который "подключается" к существующему HTML и делает его интерактивным. Это критично для SSR: HTML статичен, JavaScript делает его интерактивным.\n\nПроцесс гидратации: React находит существующий HTML, "подключается" к нему, добавляет обработчики событий, делает интерактивным. Это должно быть идентично серверному рендерингу: если HTML на сервере и клиенте не совпадает, React выдаст предупреждение о mismatch.\n\nПроблемы гидратации включают: mismatch между серверным и клиентским рендерингом, большой JavaScript бандл (нужно загрузить весь код для гидратации), время до интерактивности (TTI) всё ещё большое. Решения: частичная гидратация (гидратировать только критичные части), progressive hydration (постепенная гидратация).\n\nВ 2026 гидратация остаётся проблемой SSR. Новые подходы (Qwik resumability, React Server Components) пытаются решить проблемы гидратации, делая её более эффективной или вообще ненужной.',
    keyPoints: [
      'Гидратация: "оживление" статического HTML через JavaScript',
      'React подключается к существующему HTML, добавляет обработчики событий',
      'Должно быть идентично серверному рендерингу (иначе mismatch)',
      'Проблемы: mismatch, большой бандл, время до интерактивности',
      'Решения: частичная гидратация, progressive hydration',
      'Новые подходы пытаются решить проблемы гидратации'
    ],
    funFact: 'Термин "hydration" был придуман сообществом React для описания процесса подключения JavaScript к существующему HTML. Это аналогия с гидратацией в химии, где вещество поглощает воду и становится активным.',
    tags: ['frameworks', 'rendering', 'hydration', 'ssr', 'intermediate', 'core'],
    examples: [
      {
        title: 'Процесс гидратации',
        code: `// 1. Сервер отправляет HTML
<div id="app">
  <button>Кликни меня</button>
</div>

// 2. Браузер показывает HTML (статичный)

// 3. JavaScript загружается и выполняется

// 4. Гидратация: React подключается к HTML
ReactDOM.hydrate(
  <App />,
  document.getElementById('app')
);

// 5. React находит существующий HTML
// 6. Проверяет соответствие (если не совпадает — предупреждение)
// 7. Добавляет обработчики событий
// 8. HTML становится интерактивным

// Важно: серверный и клиентский рендеринг должны быть идентичны`
      },
      {
        title: 'Проблема mismatch',
        code: `// ❌ Проблема: mismatch между сервером и клиентом
// Сервер рендерит:
function App() {
  return <div>{new Date().toLocaleString()}</div>;
}
// HTML: <div>10.01.2026, 14:30:00</div>

// Клиент гидратирует (другое время):
// HTML: <div>10.01.2026, 14:30:05</div>

// React видит несоответствие и выдаёт предупреждение:
// "Warning: Text content did not match. Server: '14:30:00' Client: '14:30:05'"

// ✅ Решение: использовать одинаковые данные
function App({ serverTime }) {
  return <div>{serverTime}</div>;
}
// Сервер и клиент используют одинаковое значение`
      },
      {
        title: 'Частичная гидратация',
        code: `// Частичная гидратация: гидратировать только критичные части
function App() {
  return (
    <div>
      {/* Критичная часть: гидратируется сразу */}
      <Header />
      
      {/* Некритичная часть: гидратируется позже */}
      <LazyFooter />
    </div>
  );
}

// Преимущество: меньше JavaScript для первой загрузки
// Быстрее Time to Interactive

// Реализация через React.lazy и Suspense:
const LazyFooter = React.lazy(() => import('./Footer'));

function App() {
  return (
    <Suspense fallback={<div>Загрузка...</div>}>
      <LazyFooter />
    </Suspense>
  );
}`
      }
    ],
    relatedTopics: ['frameworks-rendering-ssr', 'frameworks-rendering-partial-hydration'],
    isFrontendEssential: true
  },
  {
    id: 'frameworks-rendering-ssg',
    title: 'SSG',
    difficulty: 'intermediate',
    description: 'SSG (Static Site Generation) — это предварительный рендеринг HTML на этапе сборки. Вместо рендеринга на сервере при каждом запросе, HTML генерируется один раз при сборке и сохраняется как статические файлы. Это даёт максимальную скорость: нет рендеринга на сервере, HTML отдаётся сразу.\n\nSSG решает проблемы SSR: нет нагрузки на сервер (HTML уже готов), максимальная скорость (нет рендеринга при запросе), простое кэширование (статические файлы легко кэшировать). Но SSG имеет ограничения: контент должен быть известен на этапе сборки, динамический контент требует регенерации.\n\nISR (Incremental Static Regeneration) — это гибридный подход: статические страницы генерируются на этапе сборки, но могут регенерироваться по требованию или по расписанию. Это даёт преимущества SSG (скорость) и SSR (динамический контент).\n\nВ 2026 SSG стал стандартом для контентных сайтов (блоги, документация) через мета-фреймворки (Next.js, Nuxt, Gatsby). ISR расширяет возможности SSG, позволяя обновлять контент без полной пересборки.',
    keyPoints: [
      'SSG: предварительный рендеринг HTML на этапе сборки',
      'Максимальная скорость: HTML уже готов, отдаётся сразу',
      'Нет нагрузки на сервер, простое кэширование',
      'Ограничение: контент должен быть известен на этапе сборки',
      'ISR: гибридный подход, статические страницы могут регенерироваться',
      'Стандарт для контентных сайтов в 2026'
    ],
    funFact: 'SSG существовал с самого начала веба (статические HTML файлы), но стал популярным снова в 2010-х годах с появлением генераторов статических сайтов (Jekyll, Hugo, Gatsby). Next.js добавил SSG в 2019 году, показав что можно комбинировать SSG и SSR.',
    tags: ['frameworks', 'rendering', 'ssg', 'static', 'isr', 'intermediate'],
    examples: [
      {
        title: 'SSG: предварительный рендеринг',
        code: `// SSG: рендеринг на этапе сборки
// build.js
const posts = getAllPosts(); // Получаем данные

posts.forEach(post => {
  // Рендерим HTML для каждого поста
  const html = ReactDOMServer.renderToStaticMarkup(
    <PostPage post={post} />
  );
  
  // Сохраняем как статический файл
  fs.writeFileSync(\`out/posts/\${post.slug}.html\`, html);
});

// Результат: статические HTML файлы
// out/
//   posts/
//     post-1.html
//     post-2.html
//     post-3.html

// Сервер просто отдаёт статические файлы
// Нет рендеринга при запросе, максимальная скорость`
      },
      {
        title: 'ISR: инкрементальная регенерация',
        code: `// ISR: статические страницы + регенерация
// Next.js
export async function getStaticProps({ params }) {
  const post = await getPost(params.slug);
  
  return {
    props: { post },
    // Регенерировать каждые 60 секунд
    revalidate: 60
  };
}

// Процесс:
// 1. Первый запрос: отдаётся статический HTML (быстро)
// 2. Если страница старше 60 секунд: регенерируется в фоне
// 3. Следующий запрос: отдаётся новый HTML

// Преимущество: скорость SSG + динамический контент SSR
// Недостаток: может быть устаревший контент до регенерации`
      },
      {
        title: 'SSG vs SSR',
        code: `// SSG: преимущества и недостатки
// Преимущества:
// - Максимальная скорость (HTML уже готов)
// - Нет нагрузки на сервер
// - Простое кэширование

// Недостатки:
// - Контент должен быть известен на этапе сборки
// - Динамический контент требует регенерации
// - Долгая сборка для больших сайтов

// SSR: преимущества и недостатки
// Преимущества:
// - Динамический контент при каждом запросе
// - Всегда актуальный контент

// Недостатки:
// - Нагрузка на сервер
// - Медленнее чем SSG

// Выбор: SSG для статического контента, SSR для динамического`
      }
    ],
    relatedTopics: ['frameworks-rendering-ssr', 'frameworks-rendering-partial-hydration'],
    isFrontendEssential: false
  }
];
