import { Topic } from '../../../../types';

export const RENDERING_ADVANCED_TOPICS: Topic[] = [
  {
    id: 'frameworks-rendering-partial-hydration',
    title: 'Partial hydration',
    difficulty: 'advanced',
    description: 'Partial hydration — это гидратация только критичных частей страницы, а не всей страницы сразу. Некритичные части гидратируются позже (lazy hydration) или вообще не гидратируются, если они статичны. Это снижает количество JavaScript для первой загрузки и улучшает Time to Interactive.\n\nКритичные части — это те, с которыми пользователь взаимодействует сразу: формы, кнопки, навигация. Некритичные части — это те, которые не требуют интерактивности: статичный текст, изображения, футер. Гидратируя только критичные части, можно значительно снизить JavaScript бандл для первой загрузки.\n\nРеализация включает: разделение компонентов на критичные и некритичные, lazy loading некритичных компонентов, использование React.lazy и Suspense для отложенной гидратации. Это требует архитектурных решений: какие части критичны, как разделить код.\n\nВ 2026 partial hydration становится популярным через мета-фреймворки (Next.js partial prerendering, Astro islands). Это позволяет комбинировать преимущества SSG (быстрая загрузка) и CSR (интерактивность) для критичных частей.',
    keyPoints: [
      'Partial hydration: гидратация только критичных частей',
      'Снижает JavaScript бандл для первой загрузки',
      'Улучшает Time to Interactive',
      'Критичные части: формы, кнопки, навигация',
      'Некритичные части: статичный текст, изображения, футер',
      'Популярно через мета-фреймворки в 2026'
    ],
    funFact: 'Partial hydration была популяризирована Astro в 2021 году через концепцию "islands architecture". Идея в том, что страница состоит из "островов" интерактивности в море статичного контента.',
    tags: ['frameworks', 'rendering', 'partial-hydration', 'islands', 'performance', 'advanced'],
    examples: [
      {
        title: 'Partial hydration: критичные и некритичные части',
        code: `// Partial hydration: разделение на критичные и некритичные
function Page() {
  return (
    <div>
      {/* Критичная часть: гидратируется сразу */}
      <Header /> {/* Навигация, нужна интерактивность */}
      <SearchForm /> {/* Форма поиска, нужна интерактивность */}
      
      {/* Некритичная часть: гидратируется позже */}
      <LazyArticleList /> {/* Статичный список, можно отложить */}
      <LazyFooter /> {/* Статичный футер, можно отложить */}
    </div>
  );
}

// Lazy компоненты загружаются и гидратируются позже
const LazyArticleList = React.lazy(() => import('./ArticleList'));
const LazyFooter = React.lazy(() => import('./Footer'));

// Преимущество: меньше JavaScript для первой загрузки
// Быстрее Time to Interactive`
      },
      {
        title: 'Islands Architecture',
        code: `// Islands Architecture: острова интерактивности
// Astro
---
import Search from '../components/Search.astro';
import Cart from '../components/Cart.vue';
---

<main>
  <!-- Статичный HTML -->
  <h1>Магазин</h1>
  <p>Описание...</p>
  
  <!-- Острова (интерактивные части) -->
  <Search client:load /> <!-- Загрузится сразу -->
  <Cart client:visible /> <!-- Загрузится при появлении в viewport -->
</main>

// Преимущество: статичный контент не требует JavaScript
// Только интерактивные части гидратируются
// Минимальный JavaScript бандл`
      },
      {
        title: 'Next.js Partial Prerendering',
        code: `// Next.js Partial Prerendering (экспериментально)
// Комбинирует SSG и CSR
export default function Page() {
  return (
    <div>
      {/* Статичная часть: предрендерится */}
      <StaticContent />
      
      {/* Динамическая часть: рендерится на клиенте */}
      <Suspense fallback={<Skeleton />}>
        <DynamicContent />
      </Suspense>
    </div>
  );
}

// Преимущество: быстрая загрузка статики + интерактивность динамики
// Гибридный подход: лучшее из обоих миров`
      }
    ],
    relatedTopics: ['frameworks-rendering-islands-architecture', 'frameworks-rendering-trade-offs'],
    isFrontendEssential: false
  },
  {
    id: 'frameworks-rendering-islands-architecture',
    title: 'Islands Architecture',
    difficulty: 'advanced',
    description: 'Islands Architecture — это архитектурный паттерн, где страница состоит из "островов" интерактивности в море статичного контента. Каждый остров — это независимый компонент, который гидратируется отдельно. Статичный контент остаётся HTML и не требует JavaScript.\n\nПреимущество Islands Architecture в минимальном JavaScript: только интерактивные части требуют JavaScript, статичный контент остаётся HTML. Это даёт максимальную скорость загрузки: статичный контент отображается сразу, интерактивные части гидратируются по мере необходимости.\n\nРеализация включает: разделение на статичные и интерактивные части, независимая гидратация островов, lazy loading островов. Это требует архитектурных решений: какие части статичны, какие интерактивны, как организовать острова.\n\nВ 2026 Islands Architecture становится популярным через Astro, который популяризировал этот подход. Next.js и другие мета-фреймворки добавляют поддержку islands для улучшения производительности.',
    keyPoints: [
      'Islands Architecture: острова интерактивности в море статичного контента',
      'Минимальный JavaScript: только интерактивные части',
      'Максимальная скорость: статичный контент сразу, интерактивность по мере необходимости',
      'Независимая гидратация островов',
      'Популяризирован Astro, поддерживается мета-фреймворками',
      'Требует архитектурных решений: разделение на статичное и интерактивное'
    ],
    funFact: 'Islands Architecture был популяризирован Astro в 2021 году, но идея существовала в веб-разработке с 1990-х годов, когда использовались Java-апплеты как "острова" интерактивности в статичных страницах.',
    tags: ['frameworks', 'rendering', 'islands', 'architecture', 'performance', 'advanced'],
    examples: [
      {
        title: 'Islands Architecture в Astro',
        code: `// Astro: islands architecture
---
import Search from '../components/Search.astro';
import Cart from '../components/Cart.vue';
import ProductCard from '../components/ProductCard.jsx';
---

<main>
  <!-- Статичный HTML -->
  <h1>Магазин</h1>
  <p>Описание магазина...</p>
  
  <!-- Острова (интерактивные части) -->
  <Search client:load /> 
  <!-- Загрузится сразу, гидратируется сразу -->
  
  <Cart client:visible /> 
  <!-- Загрузится при появлении в viewport -->
  
  <ProductCard client:idle /> 
  <!-- Загрузится когда браузер простаивает -->
</main>

// Преимущество: минимальный JavaScript
// Статичный контент не требует JavaScript
// Только интерактивные части гидратируются`
      },
      {
        title: 'Независимая гидратация островов',
        code: `// Каждый остров гидратируется независимо
function Page() {
  return (
    <div>
      {/* Остров 1: гидратируется сразу */}
      <SearchForm />
      
      {/* Остров 2: гидратируется при взаимодействии */}
      <InteractiveChart />
      
      {/* Остров 3: гидратируется при появлении в viewport */}
      <LazyComments />
      
      {/* Статичный контент: не гидратируется */}
      <StaticArticle />
    </div>
  );
}

// Преимущество: каждый остров независим
// Можно гидратировать по приоритету
// Не критичные острова можно отложить`
      },
      {
        title: 'Преимущества Islands Architecture',
        code: `// Islands Architecture даёт:
// 1. Минимальный JavaScript
// Только интерактивные части требуют JavaScript
// Статичный контент остаётся HTML

// 2. Максимальная скорость
// Статичный контент отображается сразу
// Интерактивные части гидратируются по мере необходимости

// 3. Независимость островов
// Каждый остров может быть на разных фреймворках
// Можно использовать React, Vue, Svelte на одной странице

// 4. Оптимизация загрузки
// Критичные острова загружаются сразу
// Некритичные откладываются (lazy loading)`
      }
    ],
    relatedTopics: ['frameworks-rendering-partial-hydration', 'frameworks-rendering-trade-offs'],
    isFrontendEssential: false
  },
  {
    id: 'frameworks-rendering-trade-offs',
    title: 'Trade-offs: SEO, TTI, TBT, FCP',
    difficulty: 'advanced',
    description: 'Выбор стратегии рендеринга — это компромисс между метриками производительности: SEO (индексация поисковиками), TTI (Time to Interactive), TBT (Total Blocking Time), FCP (First Contentful Paint). Каждая стратегия оптимизирует одни метрики за счёт других.\n\nCSR оптимизирует TTI после первой загрузки (быстрая навигация), но жертвует FCP (пустая страница) и SEO (поисковики не видят контент). SSR оптимизирует FCP (HTML с контентом сразу) и SEO (поисковики видят контент), но жертвует TTI (нужна гидратация). SSG оптимизирует все метрики для статичного контента, но не подходит для динамического.\n\nПонимание trade-offs критично для выбора стратегии под задачу. Для контентных сайтов важны FCP и SEO → SSR/SSG. Для интерактивных приложений важен TTI → CSR. Для гибридных приложений → комбинация стратегий.\n\nВ 2026 мета-фреймворки позволяют комбинировать стратегии: SSG для статики, SSR для динамики, CSR для навигации. Это даёт лучшее из всех миров, оптимизируя все метрики.',
    keyPoints: [
      'Trade-offs между метриками: SEO, TTI, TBT, FCP',
      'CSR: оптимизирует TTI, жертвует FCP и SEO',
      'SSR: оптимизирует FCP и SEO, жертвует TTI',
      'SSG: оптимизирует все метрики для статики',
      'Выбор зависит от приоритетов: контент → SSR/SSG, интерактивность → CSR',
      'Мета-фреймворки позволяют комбинировать стратегии'
    ],
    funFact: 'Core Web Vitals (FCP, TTI, TBT) были введены Google в 2020 году как метрики производительности, которые влияют на ранжирование в поиске. Это сделало оптимизацию производительности критичной для SEO.',
    tags: ['frameworks', 'rendering', 'trade-offs', 'performance', 'seo', 'metrics', 'advanced', 'core'],
    examples: [
      {
        title: 'CSR: trade-offs',
        code: `// CSR: оптимизирует TTI, жертвует FCP и SEO
// Метрики:
// - FCP: медленный (пустая страница при загрузке)
// - TTI: быстрый после первой загрузки (быстрая навигация)
// - SEO: плохое (поисковики не видят контент)
// - TBT: может быть большой (много JavaScript)

// Подходит для:
// - Интерактивные приложения (админки, дашборды)
// - Где важна скорость взаимодействия
// - Где SEO не критично

// Не подходит для:
// - Контентные сайты (блоги, новости)
// - Где важна первая загрузка
// - Где SEO критично`
      },
      {
        title: 'SSR: trade-offs',
        code: `// SSR: оптимизирует FCP и SEO, жертвует TTI
// Метрики:
// - FCP: быстрый (HTML с контентом сразу)
// - TTI: медленный (нужна гидратация)
// - SEO: отличное (поисковики видят контент)
// - TBT: может быть большой (гидратация блокирует)

// Подходит для:
// - Контентные сайты (блоги, новости)
// - Где важна первая загрузка
// - Где SEO критично

// Не подходит для:
// - Интерактивные приложения
// - Где важна скорость взаимодействия
// - Где много динамического контента`
      },
      {
        title: 'Комбинирование стратегий',
        code: `// Мета-фреймворки позволяют комбинировать стратегии
// Next.js: гибридный подход

// Статичные страницы: SSG
export async function getStaticProps() {
  return { props: { data } };
}
// → Оптимизирует FCP, SEO, TTI для статики

// Динамические страницы: SSR
export async function getServerSideProps() {
  return { props: { data: await fetchData() } };
}
// → Оптимизирует FCP, SEO для динамики

// Интерактивные части: CSR
'use client';
function InteractiveComponent() {
  // Клиентский компонент
}
// → Оптимизирует TTI для интерактивности

// Преимущество: лучшее из всех миров
// Оптимизирует все метрики под задачу`
      }
    ],
    relatedTopics: ['frameworks-rendering-ssr', 'frameworks-rendering-partial-hydration'],
    isFrontendEssential: true
  }
];
