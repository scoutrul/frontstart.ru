import { Topic } from '../../../../types';

export const REACTIVITY_BEGINNER_TOPICS: Topic[] = [
  {
    id: 'frameworks-reactivity-auto-update',
    title: 'Автоматическое обновление UI',
    difficulty: 'beginner',
    description: 'Реактивность — это автоматическое обновление интерфейса при изменении данных. Вместо того чтобы вручную обновлять каждый элемент DOM при изменении данных, вы просто изменяете данные, а фреймворк сам обновляет интерфейс. Это как магия: изменили переменную — интерфейс обновился.\n\nДо реактивных фреймворков разработчики вручную синхронизировали данные и интерфейс. Каждое изменение требовало явных команд: найти элемент, изменить его содержимое, обновить стили. Это работало для простых случаев, но в сложных приложениях превращалось в кошмар: легко забыть обновить элемент, данные рассинхронизировались, сложно было отследить откуда пришло изменение.\n\nРеактивность решает эту проблему: вы описываете зависимость между данными и интерфейсом один раз, и система сама отслеживает изменения. Когда данные меняются, интерфейс обновляется автоматически. Это не про скорость, а про предсказуемость и сокращение когнитивной нагрузки.\n\nВ 2026 реактивность стала стандартом. Все современные фреймворки (React, Vue, Angular, Svelte) используют реактивность, хотя реализация может отличаться. Понимание реактивности критично для эффективной работы с любым современным фреймворком.',
    keyPoints: [
      'Реактивность = автоматическое обновление UI при изменении данных',
      'Вместо ручного обновления DOM просто изменяете данные',
      'Система сама отслеживает изменения и обновляет интерфейс',
      'Это не про скорость, а про предсказуемость и сокращение когнитивной нагрузки',
      'Решает проблему рассинхронизации данных и интерфейса',
      'Все современные фреймворки используют реактивность'
    ],
    funFact: 'Идея реактивности пришла из функционального программирования, где функции автоматически пересчитываются при изменении входных данных. В веб-разработке это стало популярным с появлением React в 2013 году.',
    tags: ['frameworks', 'reactivity', 'ui', 'auto-update', 'basics', 'fundamentals', 'core'],
    examples: [
      {
        title: 'Без реактивности: ручное обновление',
        code: `// Без реактивности: нужно вручную обновлять каждый элемент
let count = 0;

function updateUI() {
  document.getElementById('counter').textContent = count;
  document.getElementById('status').textContent = count > 10 ? 'Много' : 'Мало';
  document.getElementById('button').disabled = count >= 20;
}

// При каждом изменении нужно помнить вызвать updateUI()
count++;
updateUI(); // Легко забыть!

count++;
// Забыли updateUI() - UI рассинхронизирован

// Проблема: легко забыть обновить элемент`
      },
      {
        title: 'С реактивностью: автоматическое обновление',
        code: `// С реактивностью: просто изменяете данные
function Counter() {
  const [count, setCount] = useState(0);
  
  // Описываете зависимость один раз
  return (
    <div>
      <p>{count}</p>
      <p>{count > 10 ? 'Много' : 'Мало'}</p>
      <button disabled={count >= 20} onClick={() => setCount(count + 1)}>
        Увеличить
      </button>
    </div>
  );
}

// При изменении count интерфейс обновится автоматически
// Не нужно помнить вызывать updateUI()
// Нельзя забыть обновить элемент`
      },
      {
        title: 'Предсказуемость реактивности',
        code: `// Реактивность даёт предсказуемость
function UserProfile({ user }) {
  // При одинаковых данных всегда одинаковый интерфейс
  return (
    <div>
      <h1>{user.name}</h1>
      <p>{user.email}</p>
      <p>Возраст: {user.age}</p>
      <p>Статус: {user.age >= 18 ? 'Взрослый' : 'Ребенок'}</p>
    </div>
  );
}

// Если user = { name: 'Иван', age: 25, email: 'ivan@example.com' }
// Всегда получите одинаковый интерфейс
// Нет скрытых зависимостей
// Нет рассинхронизации`
      }
    ],
    relatedTopics: ['frameworks-reactivity-data-down-events-up', 'frameworks-component-model-props-state-template', 'react-hooks', 'vue-reactivity'],
    isFrontendEssential: true
  },
  {
    id: 'frameworks-reactivity-data-down-events-up',
    title: 'Data down, events up',
    difficulty: 'beginner',
    description: 'Однонаправленный поток данных — это фундаментальный принцип реактивных фреймворков. Данные текут сверху вниз (data down): родительский компонент передаёт данные дочерним через props. События текут снизу вверх (events up): дочерний компонент отправляет события родителю через callbacks.\n\nЭто создаёт предсказуемый поток данных: всегда знаете откуда пришли данные (сверху) и куда идут события (наверх). Нет циклических зависимостей, нет неожиданных обновлений, легко отследить откуда пришло изменение.\n\nПреимущество однонаправленного потока в простоте понимания: данные идут в одном направлении, события в другом. Это упрощает отладку: если что-то работает неправильно, вы знаете где искать — в данных, которые пришли сверху, или в событиях, которые пошли наверх.\n\nВ 2026 однонаправленный поток данных стал стандартом во всех современных фреймворках. Даже когда используются глобальные хранилища (Redux, Zustand), принцип остаётся: данные текут в одном направлении, события в другом.',
    keyPoints: [
      'Data down: данные текут сверху вниз через props',
      'Events up: события текут снизу вверх через callbacks',
      'Однонаправленный поток создаёт предсказуемость',
      'Нет циклических зависимостей, нет неожиданных обновлений',
      'Легко отследить откуда пришло изменение',
      'Стандарт во всех современных фреймворках'
    ],
    funFact: 'Принцип "data down, events up" был популяризирован React, но идея однонаправленного потока данных существовала в программировании задолго до этого. В функциональном программировании это называется "immutable data flow".',
    tags: ['frameworks', 'reactivity', 'data-flow', 'props', 'events', 'basics', 'fundamentals', 'core'],
    examples: [
      {
        title: 'Data down: данные сверху вниз',
        code: `// Data down: данные текут от родителя к ребёнку
function App() {
  const user = { name: 'Иван', email: 'ivan@example.com' };
  
  // Передаём данные вниз через props
  return <UserProfile user={user} />;
}

function UserProfile({ user }) {
  // Получаем данные от родителя
  // Передаём дальше вниз
  return (
    <div>
      <UserName name={user.name} />
      <UserEmail email={user.email} />
    </div>
  );
}

function UserName({ name }) {
  // Получаем данные от родителя
  return <h1>{name}</h1>;
}

// Данные текут: App → UserProfile → UserName`
      },
      {
        title: 'Events up: события снизу вверх',
        code: `// Events up: события текут от ребёнка к родителю
function App() {
  const [count, setCount] = useState(0);
  
  // Callback для получения события от ребёнка
  const handleIncrement = () => {
    setCount(count + 1);
  };
  
  // Передаём callback вниз
  return <Counter onIncrement={handleIncrement} />;
}

function Counter({ onIncrement }) {
  // Отправляем событие наверх через callback
  return (
    <button onClick={onIncrement}>
      Увеличить
    </button>
  );
}

// События текут: Counter → App (через callback)`
      },
      {
        title: 'Предсказуемость однонаправленного потока',
        code: `// Однонаправленный поток даёт предсказуемость
function TodoApp() {
  const [todos, setTodos] = useState([]);
  
  // Данные текут вниз
  return (
    <div>
      <TodoList todos={todos} />
      <AddTodoForm onAdd={handleAdd} />
    </div>
  );
  
  // События текут наверх
  function handleAdd(todo) {
    setTodos([...todos, todo]);
  }
}

// Всегда знаете:
// - Откуда пришли данные (сверху)
// - Куда идут события (наверх)
// - Нет циклических зависимостей
// - Легко отследить изменения`
      }
    ],
    relatedTopics: ['frameworks-reactivity-auto-update', 'frameworks-component-model-tree'],
    isFrontendEssential: true
  },
  {
    id: 'frameworks-reactivity-declarative-vs-imperative',
    title: 'Декларативность vs Императивность',
    difficulty: 'beginner',
    description: 'Декларативный подход описывает ЧТО должно быть, императивный — КАК это сделать. В реактивных фреймворках используется декларативный подход: вы описываете как интерфейс должен выглядеть при определённых данных, а фреймворк сам решает как это реализовать.\n\nИмперативный подход требует явных команд: найти элемент, изменить его, обновить стили. Декларативный подход требует описания результата: при данных X интерфейс должен выглядеть как Y. Фреймворк сам вычисляет разницу и применяет изменения.\n\nПреимущество декларативного подхода в абстракции: вы не думаете о том, как обновить DOM, вы думаете о том, как данные преобразуются в интерфейс. Это упрощает код и делает его более предсказуемым.\n\nВ 2026 декларативный подход стал стандартом. Все современные фреймворки используют декларативный синтаксис (JSX, шаблоны), хотя под капотом они могут использовать императивные оптимизации для производительности.',
    keyPoints: [
      'Декларативный: описывает ЧТО должно быть',
      'Императивный: описывает КАК это сделать',
      'Реактивные фреймворки используют декларативный подход',
      'Декларативный подход абстрагирует от деталей DOM',
      'Упрощает код и делает его более предсказуемым',
      'Стандарт во всех современных фреймворках'
    ],
    funFact: 'Идея декларативного программирования пришла из математики и логики, где описывается результат, а не процесс его получения. В веб-разработке это стало популярным с появлением React и его JSX синтаксиса.',
    tags: ['frameworks', 'reactivity', 'declarative', 'imperative', 'basics', 'fundamentals'],
    examples: [
      {
        title: 'Императивный подход',
        code: `// Императивный: описываем КАК обновить DOM
function updateCounter(count) {
  // Явные команды: найти элемент, изменить его
  const counterEl = document.getElementById('counter');
  counterEl.textContent = count;
  
  const statusEl = document.getElementById('status');
  statusEl.textContent = count > 10 ? 'Много' : 'Мало';
  
  const buttonEl = document.getElementById('button');
  buttonEl.disabled = count >= 20;
}

// Нужно думать о том, КАК обновить каждый элемент
// Легко забыть обновить элемент
// Сложно отследить зависимости`
      },
      {
        title: 'Декларативный подход',
        code: `// Декларативный: описываем ЧТО должно быть
function Counter({ count }) {
  // Описываем результат: при count интерфейс должен выглядеть так
  return (
    <div>
      <p>{count}</p>
      <p>{count > 10 ? 'Много' : 'Мало'}</p>
      <button disabled={count >= 20}>
        Увеличить
      </button>
    </div>
  );
}

// Не думаем о том, КАК обновить DOM
// Думаем о том, КАК данные преобразуются в интерфейс
// Фреймворк сам решает как применить изменения`
      },
      {
        title: 'Абстракция декларативного подхода',
        code: `// Декларативный подход абстрагирует от деталей
function UserList({ users, filter }) {
  // Описываем результат: список отфильтрованных пользователей
  const filteredUsers = users.filter(user => 
    user.name.includes(filter)
  );
  
  return (
    <ul>
      {filteredUsers.map(user => (
        <li key={user.id}>{user.name}</li>
      ))}
    </ul>
  );
}

// Не думаем о:
// - Как найти элементы DOM
// - Как добавить/удалить элементы
// - Как обновить стили

// Думаем только о:
// - Какие данные
// - Как они преобразуются
// - Как выглядят

// Фреймворк сам решает детали обновления DOM`
      }
    ],
    relatedTopics: ['frameworks-reactivity-auto-update', 'frameworks-evolution-declarative-ui'],
    isFrontendEssential: false
  }
];
