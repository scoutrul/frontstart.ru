import { Topic } from '../../../../types';

export const FUTURE_ADVANCED_TOPICS: Topic[] = [
  {
    id: 'frameworks-future-compilation-hydration',
    title: 'Компиляция и частичная гидратация',
    difficulty: 'advanced',
    description: 'Компиляция и частичная гидратация — это тренды 2026 для оптимизации производительности. Компиляция снижает runtime overhead: React Forget компилирует компоненты с оптимизациями, Svelte компилирует компоненты в нативный JavaScript, Vue компилирует шаблоны с оптимизациями. Это даёт лучшее из обоих миров: хороший DX и низкий runtime cost.\n\nЧастичная гидратация снижает количество JavaScript для первой загрузки: гидратируются только критичные части, некритичные откладываются или не гидратируются вообще. Islands Architecture реализует частичную гидратацию через независимые островки интерактивности. Это даёт быструю загрузку статичного контента и интерактивность только там, где нужно.\n\nРезумейбилити (resumability) — это подход, где выполнение продолжается с сервера без гидратации. Qwik реализует resumability через сериализацию состояния и продолжение выполнения на клиенте. Это даёт минимальную гидратацию и быструю интерактивность.\n\nВ 2026 компиляция и частичная гидратация становятся стандартом для оптимизации производительности. Они дают лучшее из обоих миров: хороший DX и низкий runtime cost. Понимание этих подходов критично для создания производительных приложений.',
    keyPoints: [
      'Компиляция снижает runtime overhead: React Forget, Svelte, Vue',
      'Частичная гидратация: гидратируются только критичные части',
      'Islands Architecture: независимые островки интерактивности',
      'Resumability: продолжение выполнения с сервера без гидратации',
      'Дают лучшее из обоих миров: хороший DX и низкий runtime cost',
      'Стандарт для оптимизации производительности в 2026'
    ],
    funFact: 'Resumability был изобретён Миславом Хорватом в Qwik как способ избежать гидратации. Идея в том, что сервер сериализует состояние, а клиент продолжает выполнение без необходимости гидратации. Это даёт минимальный JavaScript и быструю интерактивность.',
    tags: ['frameworks', 'future', 'compilation', 'hydration', 'resumability', 'advanced', 'performance'],
    examples: [
      {
        title: 'React Forget: компиляция',
        code: `// React Forget: компиляция с оптимизациями
// Исходный код (простой):
function Component({ items, filter }) {
  const filtered = items.filter(item => 
    item.name.includes(filter)
  );
  return <List items={filtered} />;
}

// Компилятор оптимизирует:
// - Автоматическая мемоизация filtered
// - Оптимизация ререндеров
// - Снижение runtime overhead

// Результат: хороший DX + низкий runtime cost
// Разработчик пишет простой код
// Компилятор оптимизирует его`
      },
      {
        title: 'Частичная гидратация',
        code: `// Частичная гидратация: только критичные части
function Page() {
  return (
    <div>
      {/* Критичная часть: гидратируется сразу */}
      <Header />
      <SearchForm />
      
      {/* Некритичная часть: гидратируется позже */}
      <LazyArticleList />
      <LazyFooter />
    </div>
  );
}

// Преимущество: меньше JavaScript для первой загрузки
// Быстрее Time to Interactive
// Критичные части интерактивны сразу`
      },
      {
        title: 'Resumability в Qwik',
        code: `// Qwik: resumability
// Сервер рендерит и сериализует:
export default component$(() => {
  const count = useSignal(0);
  return <button onClick$={() => count.value++}>{count.value}</button>;
});

// HTML с сериализованным состоянием:
<button q:obj="1" on:click="./chunk.js#handler">
  0
</button>
<script type="application/json">{"count":0}</script>

// Клиент продолжает выполнение:
// 1. HTML уже отрендерен
// 2. Состояние десериализовано
// 3. Обработчики загружаются по требованию
// 4. Нет гидратации

// Преимущество: минимальный JavaScript
// Быстрая интерактивность
// Подходит для контентных сайтов`
      }
    ],
    relatedTopics: ['frameworks-future-compiler', 'frameworks-future-htmx-alpine'],
    isFrontendEssential: false
  },
  {
    id: 'frameworks-future-compiler',
    title: 'Фреймворк как компилятор',
    difficulty: 'advanced',
    description: 'Фреймворк как компилятор — это подход, где фреймворк компилирует код в более эффективный, снижая runtime overhead. Svelte был первым фреймворком, который полностью полагался на компиляцию: компоненты компилируются в нативный JavaScript без runtime overhead. React Forget и Vue компилируют с оптимизациями, снижая overhead при сохранении runtime.\n\nПреимущества компиляции: снижение runtime overhead (компилятор оптимизирует код), сохранение DX (разработчик пишет простой код), автоматические оптимизации (компилятор применяет лучшие практики). Но компиляция имеет стоимость: нужен этап компиляции, сложнее отладка скомпилированного кода.\n\nТренд 2026: компиляция становится стандартом. React Forget компилирует компоненты с оптимизациями, Svelte компилирует компоненты в нативный JavaScript, Vue компилирует шаблоны с оптимизациями. Это даёт лучшее из обоих миров: хороший DX и низкий runtime cost.\n\nВ 2026 фреймворк как компилятор становится популярным подходом. Понимание компиляции критично для создания производительных приложений и выбора правильного инструмента.',
    keyPoints: [
      'Фреймворк как компилятор: компиляция в более эффективный код',
      'Svelte: полная компиляция в нативный JavaScript',
      'React Forget, Vue: компиляция с оптимизациями',
      'Преимущества: снижение runtime overhead, сохранение DX, автоматические оптимизации',
      'Стоимость: этап компиляции, сложнее отладка',
      'Стандарт в 2026: компиляция становится популярной'
    ],
    funFact: 'Svelte был создан в 2016 году с идеей "компилятор, а не фреймворк". Это означало, что весь runtime overhead можно устранить через компиляцию. За годы эта идея стала популярной, и другие фреймворки начали использовать компиляцию для оптимизации.',
    tags: ['frameworks', 'future', 'compilation', 'compiler', 'svelte', 'advanced'],
    examples: [
      {
        title: 'Svelte: полная компиляция',
        code: `// Svelte: компиляция в нативный JavaScript
// Исходный код:
<script>
  let count = 0;
  $: doubled = count * 2;
</script>

<button on:click={() => count++}>
  {count} (удвоено: {doubled})
</button>

// Компилятор генерирует оптимизированный код:
function create_fragment(ctx) {
  let button, t0, t1, t2, t3;
  return {
    c() {
      button = element("button");
      t0 = text("0");
      t1 = text(" (удвоено: ");
      t2 = text("0");
      t3 = text(")");
    },
    m(target, anchor) {
      insert(target, button, anchor);
      append(button, t0);
      append(button, t1);
      append(button, t2);
      append(button, t3);
      button.addEventListener("click", ctx[0]);
    },
    p(ctx, [dirty]) {
      if (dirty & 1) set_data(t0, ctx[0]);
      if (dirty & 1) set_data(t2, ctx[0] * 2);
    }
  };
}

// Преимущество: нет runtime overhead
// Компилируется в эффективный код
// Минимальный бандл`
      },
      {
        title: 'React Forget: компиляция с оптимизациями',
        code: `// React Forget: компиляция с оптимизациями
// Исходный код:
function Component({ items, filter }) {
  const filtered = items.filter(item => 
    item.name.includes(filter)
  );
  return <List items={filtered} />;
}

// Компилятор оптимизирует:
// - Автоматическая мемоизация filtered
// - Оптимизация ререндеров
// - Снижение runtime overhead

// Результат: хороший DX + низкий runtime cost
// Разработчик пишет простой код
// Компилятор оптимизирует его`
      },
      {
        title: 'Преимущества компиляции',
        code: `// Компиляция даёт:
// 1. Снижение runtime overhead
// Компилятор оптимизирует код
// Нет лишних вычислений

// 2. Сохранение DX
// Разработчик пишет простой код
// Компилятор оптимизирует его

// 3. Автоматические оптимизации
// Компилятор применяет лучшие практики
// Не нужно думать об оптимизации

// 4. Меньший бандл
// Компилятор удаляет неиспользуемый код
// Оптимизирует импорты

// Преимущество: лучшее из обоих миров
// Хороший DX + низкий runtime cost`
      }
    ],
    relatedTopics: ['frameworks-future-compilation-hydration', 'frameworks-reactivity-runtime-vs-compile-time'],
    isFrontendEssential: false
  },
  {
    id: 'frameworks-future-htmx-alpine',
    title: 'HTMX + Alpine',
    difficulty: 'advanced',
    description: 'HTMX + Alpine — это возврат к простым моделям разработки. HTMX добавляет интерактивность через HTML атрибуты без JavaScript, Alpine.js добавляет реактивность через HTML директивы с минимальным JavaScript. Вместо сложных фреймворков используется простой подход: HTML с атрибутами и минимальный JavaScript.\n\nHTMX решает проблему сложности фреймворков: вместо написания JavaScript для AJAX запросов, используются HTML атрибуты. Alpine.js решает проблему реактивности: вместо сложной системы реактивности, используются простые директивы. Это даёт простоту разработки без overhead фреймворков.\n\nПреимущества HTMX + Alpine: простота (HTML с атрибутами, минимальный JavaScript), производительность (нет overhead фреймворков), маленький размер (Alpine.js ~15KB). Но есть ограничения: не подходит для сложных приложений, меньшая экосистема, меньше инструментов разработки.\n\nВ 2026 HTMX + Alpine становятся популярными для простых приложений и как альтернатива сложным фреймворкам. Они показывают, что не всегда нужны сложные фреймворки: иногда простой подход лучше. Понимание HTMX + Alpine помогает выбрать правильный подход под задачу.',
    keyPoints: [
      'HTMX + Alpine: возврат к простым моделям',
      'HTMX: интерактивность через HTML атрибуты',
      'Alpine.js: реактивность через HTML директивы',
      'Преимущества: простота, производительность, маленький размер',
      'Ограничения: не подходит для сложных приложений',
      'Популярны для простых приложений в 2026'
    ],
    funFact: 'HTMX был создан в 2020 году Карсоном Гроссом как способ добавить интерактивность без сложных фреймворков. Идея в том, что HTML атрибуты могут определять поведение, не требуя написания JavaScript. Это возврат к простым моделям разработки 2000-х годов.',
    tags: ['frameworks', 'future', 'htmx', 'alpine', 'simplicity', 'advanced'],
    examples: [
      {
        title: 'HTMX: интерактивность через атрибуты',
        code: `// HTMX: интерактивность через HTML атрибуты
// Вместо JavaScript:
<button 
  hx-post="/api/increment"
  hx-target="#counter"
  hx-swap="innerHTML"
>
  Увеличить
</button>

<div id="counter">0</div>

// HTMX автоматически:
// 1. Отправляет POST запрос при клике
// 2. Обновляет #counter результатом
// 3. Не нужно писать JavaScript

// Преимущество: простота
// HTML с атрибутами
// Минимальный JavaScript`
      },
      {
        title: 'Alpine.js: реактивность через директивы',
        code: `// Alpine.js: реактивность через HTML директивы
<div x-data="{ count: 0 }">
  <button @click="count++">
    Увеличить
  </button>
  <p x-text="count"></p>
</div>

// Alpine.js автоматически:
// 1. Создаёт реактивное состояние
// 2. Обновляет DOM при изменении
// 3. Не нужно писать JavaScript

// Преимущество: простота
// HTML директивы
// Минимальный JavaScript (~15KB)`
      },
      {
        title: 'Когда использовать',
        code: `// ✅ HTMX + Alpine подходят для:
// - Простые приложения
// - Контентные сайты
// - Формы и интерактивность
// - Где не нужна сложная логика

// ❌ Не подходят для:
// - Сложные приложения
// - Много состояния
// - Сложная бизнес-логика
// - Где нужна большая экосистема

// Выбор: простота vs возможности
// HTMX + Alpine: простота
// React/Vue: возможности`
      }
    ],
    relatedTopics: ['frameworks-future-compiler', 'frameworks-evolution-cost-of-abstractions'],
    isFrontendEssential: false
  }
];
