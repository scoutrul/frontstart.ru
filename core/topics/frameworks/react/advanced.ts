import { Topic } from '../../../types';

export const REACT_ADVANCED_TOPICS: Topic[] = [
  {
    id: 'react-migration-classes',
    title: 'Миграция: классы → функции',
    difficulty: 'advanced',
    description: 'Миграция от классовых компонентов к функциональным — это процесс переписывания классовых компонентов на функциональные с хуками. Классовые компоненты устарели: хуки предоставляют те же возможности с более простым синтаксисом. Миграция улучшает читаемость кода и упрощает поддержку.\n\nСтратегии миграции: постепенная миграция (по одному компоненту), полная миграция (все сразу), гибридный подход (классовые и функциональные вместе). Выбор зависит от размера проекта и рисков: постепенная миграция безопаснее, полная быстрее.\n\nПреобразование: componentDidMount → useEffect, componentDidUpdate → useEffect с зависимостями, componentWillUnmount → cleanup в useEffect, this.state → useState, this.props → props параметр. Понимание преобразования критично для успешной миграции.\n\nВ 2026 миграция от классов к функциям стала стандартом. Новые проекты используют только функциональные компоненты, старые проекты мигрируют постепенно. Понимание миграции критично для работы с legacy кодом.',
    keyPoints: [
      'Миграция: классы → функции с хуками',
      'Стратегии: постепенная, полная, гибридный подход',
      'Преобразование: lifecycle методы → useEffect, this.state → useState',
      'Улучшает читаемость и упрощает поддержку',
      'Стандарт для новых проектов в 2026',
      'Критично для работы с legacy кодом'
    ],
    funFact: 'Миграция от классов к функциям стала особенно актуальной после появления хуков в React 16.8. Многие команды начали мигрировать существующие проекты, что создало спрос на понимание процесса миграции.',
    tags: ['react', 'migration', 'classes', 'hooks', 'legacy', 'advanced'],
    examples: [
      {
        title: 'Преобразование классового компонента',
        code: `// Классовый компонент
class UserProfile extends React.Component {
  constructor(props) {
    super(props);
    this.state = { user: null };
  }
  
  componentDidMount() {
    fetchUser(this.props.userId).then(user => {
      this.setState({ user });
    });
  }
  
  componentDidUpdate(prevProps) {
    if (prevProps.userId !== this.props.userId) {
      fetchUser(this.props.userId).then(user => {
        this.setState({ user });
      });
    }
  }
  
  render() {
    if (!this.state.user) return <div>Загрузка...</div>;
    return <div>{this.state.user.name}</div>;
  }
}

// Функциональный компонент с хуками
function UserProfile({ userId }) {
  const [user, setUser] = useState(null);
  
  useEffect(() => {
    fetchUser(userId).then(setUser);
  }, [userId]);
  
  if (!user) return <div>Загрузка...</div>;
  return <div>{user.name}</div>;
}

// Преимущество: проще, меньше кода
// Легче понять и поддерживать`
      },
      {
        title: 'Стратегии миграции',
        code: `// Постепенная миграция (безопаснее)
// 1. Начать с простых компонентов
// 2. Мигрировать по одному
// 3. Тестировать после каждой миграции

// Полная миграция (быстрее)
// 1. Переписать все компоненты
// 2. Протестировать всё сразу
// 3. Больше рисков, но быстрее

// Гибридный подход (компромисс)
// 1. Новые компоненты на функциях
// 2. Старые компоненты постепенно мигрировать
// 3. Классовые и функциональные вместе

// Выбор зависит от:
// - Размера проекта
// - Рисков
// - Времени`
      },
      {
        title: 'Преобразование lifecycle',
        code: `// Преобразование lifecycle методов:
// componentDidMount → useEffect(() => {}, [])
useEffect(() => {
  // Код выполняется после монтирования
}, []);

// componentDidUpdate → useEffect с зависимостями
useEffect(() => {
  // Код выполняется при изменении зависимостей
}, [dependency]);

// componentWillUnmount → cleanup в useEffect
useEffect(() => {
  return () => {
    // Cleanup выполняется при размонтировании
  };
}, []);

// Преимущество: единый API для всех эффектов
// Проще понять и поддерживать`
      }
    ],
    relatedTopics: ['react-2028', 'frameworks-evolution-criteria'],
    isFrontendEssential: false
  },
  {
    id: 'react-2028',
    title: 'React в 2028',
    difficulty: 'advanced',
    description: 'React в 2028 — это спекуляция о будущем React на основе текущих трендов. Вероятные изменения: компиляция станет стандартом (React Forget автоматизирует оптимизации), Server Components станут основой (больше серверного рендеринга), Concurrent Features станут обязательными (приоритизация обновлений). Но основы останутся: компоненты как функции, однонаправленный поток данных.\n\nТренды: меньше JavaScript на клиенте (Server Components, компиляция), больше автоматизации (компилятор оптимизирует код), лучше производительность (компиляция снижает overhead). Но React останется React: компонентная модель, реактивность, экосистема.\n\nВозможные изменения: React Forget станет обязательным (автоматическая оптимизация), Server Components станут основой (больше серверного рендеринга), новые хуки для новых возможностей. Но понимание основ останется важным: компоненты, хуки, состояние, эффекты.\n\nВ 2026 спекуляция о React в 2028 помогает понять направление развития. Понимание трендов критично для долгосрочной карьеры и выбора технологий.',
    keyPoints: [
      'Спекуляция о будущем React на основе трендов',
      'Вероятные изменения: компиляция, Server Components, Concurrent Features',
      'Основы останутся: компоненты как функции, однонаправленный поток',
      'Тренды: меньше JavaScript, больше автоматизации, лучше производительность',
      'Понимание трендов критично для долгосрочной карьеры',
      'Спекуляция помогает понять направление развития'
    ],
    funFact: 'Спекуляция о будущем технологий стала популярной в 2020-х годах с ростом скорости изменений. Понимание трендов помогает разработчикам готовиться к будущему и выбирать технологии, которые останутся актуальными.',
    tags: ['react', 'future', 'speculation', 'trends', 'advanced'],
    examples: [
      {
        title: 'Вероятные изменения',
        code: `// React в 2028 (спекуляция):
// 1. Компиляция станет стандартом
// React Forget автоматизирует оптимизации
// Не нужно думать о мемоизации

// 2. Server Components станут основой
// Больше серверного рендеринга
// Меньше JavaScript на клиенте

// 3. Concurrent Features обязательны
// Приоритизация обновлений
// Отзывчивые интерфейсы

// 4. Новые хуки для новых возможностей
// use() для промисов и контекста
// Новые хуки для новых паттернов

// Но основы останутся:
// - Компоненты как функции
// - Однонаправленный поток
// - Экосистема`
      },
      {
        title: 'Тренды',
        code: `// Тренды в React:
// 1. Меньше JavaScript на клиенте
// Server Components рендерятся на сервере
// Компиляция оптимизирует код

// 2. Больше автоматизации
// Компилятор оптимизирует код
// Не нужно думать об оптимизации

// 3. Лучшая производительность
// Компиляция снижает overhead
// Server Components снижают бандл

// 4. Лучший DX
// Проще писать код
// Компилятор оптимизирует

// Результат: лучшее из обоих миров
// Хороший DX + низкий runtime cost`
      },
      {
        title: 'Подготовка к будущему',
        code: `// Подготовка к будущему React:
// 1. Понимать основы
// Компоненты, хуки, состояние
// Основы не изменятся

// 2. Изучать тренды
// Server Components, компиляция
// Направление развития

// 3. Адаптироваться к изменениям
// Новые возможности
// Новые подходы

// 4. Фокусироваться на концепциях
// Не только API, но и принципы
// Концепции остаются актуальными

// Преимущество: готовность к изменениям
// Быстрая адаптация к новому
// Долгосрочная карьера`
      }
    ],
    relatedTopics: ['react-migration-classes', 'frameworks-future-compilation-hydration'],
    isFrontendEssential: false
  }
];
