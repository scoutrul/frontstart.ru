import { Topic } from '../../../types';

export const REACT_BEGINNER_TOPICS: Topic[] = [
  {
    id: 'react-mental-model',
    title: 'Ментальная модель',
    difficulty: 'beginner',
    description: 'Ментальная модель React — это способ понимания как React работает. Компоненты это функции, которые принимают props и возвращают описание UI. React вызывает эти функции, сравнивает результаты, и обновляет DOM только там, где нужно. Это создаёт предсказуемость: при одинаковых props всегда одинаковый результат.\n\nОднонаправленный поток данных — это фундаментальный принцип React: данные текут сверху вниз через props, события текут снизу вверх через callbacks. Это создаёт предсказуемость: всегда знаете откуда пришли данные и куда идут события. Нет циклических зависимостей, нет неожиданных обновлений.\n\nКомпоненты как функции — это ключевая идея React: компонент это функция от props, которая возвращает описание UI. Это упрощает понимание: компонент вызывается с props, возвращает JSX, React рендерит JSX в DOM. При изменении props компонент вызывается снова, React сравнивает результаты и обновляет DOM.\n\nВ 2026 ментальная модель React остаётся актуальной, хотя добавляются новые концепции (Server Components, Concurrent Features). Понимание ментальной модели критично для эффективной работы с React.',
    keyPoints: [
      'Компоненты это функции: принимают props, возвращают описание UI',
      'Однонаправленный поток: данные вниз через props, события наверх через callbacks',
      'React вызывает компоненты, сравнивает результаты, обновляет DOM',
      'Предсказуемость: при одинаковых props всегда одинаковый результат',
      'Ключевая идея: компонент = функция от props',
      'Критично для эффективной работы с React'
    ],
    funFact: 'Идея "компоненты как функции" была ключевой инновацией React в 2013 году. До этого компоненты были классами, что усложняло понимание. Функциональные компоненты упростили ментальную модель, сделав React более доступным.',
    tags: ['react', 'mental-model', 'components', 'data-flow', 'basics', 'fundamentals', 'core'],
    examples: [
      {
        title: 'Компоненты как функции',
        code: `// Компонент это функция от props
function Welcome({ name }) {
  // Принимает props
  // Возвращает описание UI
  return <h1>Привет, {name}!</h1>;
}

// React вызывает функцию:
// Welcome({ name: 'Иван' })
// → <h1>Привет, Иван!</h1>

// При изменении props:
// Welcome({ name: 'Мария' })
// → <h1>Привет, Мария!</h1>

// React сравнивает результаты
// Обновляет только изменившееся

// Преимущество: предсказуемость
// При одинаковых props всегда одинаковый результат`
      },
      {
        title: 'Однонаправленный поток',
        code: `// Однонаправленный поток данных
function App() {
  const [count, setCount] = useState(0);
  
  // Данные текут вниз через props
  return <Counter count={count} onIncrement={() => setCount(count + 1)} />;
}

function Counter({ count, onIncrement }) {
  // Получает данные сверху
  // Отправляет события наверх через callback
  return (
    <div>
      <p>{count}</p>
      <button onClick={onIncrement}>+</button>
    </div>
  );
}

// Поток: App → Counter (данные), Counter → App (события)
// Предсказуемо: всегда знаете откуда данные и куда события`
      },
      {
        title: 'Предсказуемость',
        code: `// Предсказуемость: при одинаковых props всегда одинаковый результат
function UserCard({ user }) {
  // Для { name: 'Иван', age: 25 } всегда вернёт одинаковый UI
  return (
    <div>
      <h1>{user.name}</h1>
      <p>Возраст: {user.age}</p>
      <p>Статус: {user.age >= 18 ? 'Взрослый' : 'Ребенок'}</p>
    </div>
  );
}

// Преимущество: легко тестировать
// Легко отлаживать
// Нет скрытых зависимостей`
      }
    ],
    relatedTopics: ['react-hooks', 'frameworks-component-model-atom'],
    isFrontendEssential: true
  },
  {
    id: 'react-hooks',
    title: 'Хуки',
    difficulty: 'beginner',
    description: 'Хуки — это функции, которые позволяют использовать состояние и жизненный цикл в функциональных компонентах. useState для локального состояния, useEffect для побочных эффектов, useContext для контекста. Хуки решают проблему состояния в функциональных компонентах: до хуков только классовые компоненты могли иметь состояние.\n\nЭволюция API: useState (базовое состояние), useEffect (побочные эффекты), useContext (контекст), useReducer (сложное состояние), useMemo/useCallback (оптимизация), use (новый хук для промисов и контекста). Каждый хук решает свою задачу, создавая систему для управления состоянием и эффектами.\n\nПравила хуков: хуки можно вызывать только на верхнем уровне компонента (не в циклах, условиях, вложенных функциях), хуки можно вызывать только из функциональных компонентов или других хуков. Эти правила обеспечивают стабильность работы хуков: React полагается на порядке вызова хуков для управления состоянием.\n\nВ 2026 хуки стали стандартом React. Новые хуки (use) расширяют возможности, но базовые хуки остаются основой. Понимание хуков критично для эффективной работы с React.',
    keyPoints: [
      'Хуки: функции для состояния и жизненного цикла в функциональных компонентах',
      'useState: локальное состояние, useEffect: побочные эффекты, useContext: контекст',
      'Эволюция API: от useState до use (новый хук для промисов)',
      'Правила хуков: только на верхнем уровне, только из компонентов или хуков',
      'Решают проблему состояния в функциональных компонентах',
      'Стандарт React в 2026'
    ],
    funFact: 'Хуки были добавлены в React 16.8 в 2019 году как способ использовать состояние в функциональных компонентах. До этого только классовые компоненты могли иметь состояние. Хуки сделали функциональные компоненты полноценными, упростив код и ментальную модель.',
    tags: ['react', 'hooks', 'useState', 'useEffect', 'basics', 'fundamentals', 'core'],
    examples: [
      {
        title: 'useState: базовое состояние',
        code: `// useState: локальное состояние
function Counter() {
  // useState возвращает [значение, функция обновления]
  const [count, setCount] = useState(0);
  
  return (
    <div>
      <p>{count}</p>
      <button onClick={() => setCount(count + 1)}>+</button>
    </div>
  );
}

// При клике:
// setCount(count + 1) обновляет состояние
// React перерисовывает компонент
// count обновляется в UI

// Преимущество: простота
// Не нужно думать о жизненном цикле`
      },
      {
        title: 'useEffect: побочные эффекты',
        code: `// useEffect: побочные эффекты
function UserProfile({ userId }) {
  const [user, setUser] = useState(null);
  
  // Выполняется после рендера
  useEffect(() => {
    // Побочный эффект: запрос данных
    fetchUser(userId).then(setUser);
  }, [userId]); // Зависимости: выполняется при изменении userId
  
  if (!user) return <div>Загрузка...</div>;
  
  return <div>{user.name}</div>;
}

// useEffect решает проблему:
// - Запросы данных
// - Подписки
// - Очистка ресурсов

// Преимущество: побочные эффекты в одном месте`
      },
      {
        title: 'Правила хуков',
        code: `// ❌ Нарушение правил хуков
function Component({ condition }) {
  if (condition) {
    const [count, setCount] = useState(0); // ❌ В условии
  }
  
  for (let i = 0; i < 10; i++) {
    const [item, setItem] = useState(i); // ❌ В цикле
  }
  
  function handleClick() {
    const [clicked, setClicked] = useState(false); // ❌ В функции
  }
}

// ✅ Правильное использование
function Component({ condition }) {
  // Хуки только на верхнем уровне
  const [count, setCount] = useState(0);
  const [items, setItems] = useState([]);
  
  useEffect(() => {
    // Логика в useEffect
  }, []);
  
  // Условная логика в теле компонента
  if (condition) {
    // Используем count, но не создаём новые хуки
  }
}

// Преимущество: стабильность работы хуков
// React полагается на порядок вызова`
      }
    ],
    relatedTopics: ['react-mental-model', 'react-server-components'],
    isFrontendEssential: true
  }
];
